;;; Functions that have been changed by Daniel from search.lisp and some new ones for ERRT
(defvar *errt-output-threshold* 1)
(defvar *distance-computation* nil)
(defvar *print-reuse* nil)
(defvar *print-all-mem* nil)
(defvar *modified-probset* nil)


(defun learning-enforced-hill-climbing (init-node h-fn cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let ((open-nodes nil) (open-children nil)
	(node init-node) (next-node nil) (visited (make-hash-table))
	(current-h 0) (current-h-plus 0) (better-h-node nil) (discrete-h (not (is-metric-domain)))
	(lookahead (search-option-value :lookahead search-options))
	(helpful (search-option-value :helpful search-options))
	(use-rules-p (car (find-argument search-options :use-rules-p))))

    (cond (*trace-mem* 
	   (say-consed-bytes :mem-per-node (store-h-extras node h-fn))
	   (write-node-mem-info 'ehc))
	  (t (store-h-extras node h-fn)))

    (setf current-h (snode-h-value node))
    (setf current-h-plus (snode-h-plus node))
    (when (and use-rules-p *rete-root-node*)
	(push-to-rete-goals)
	(push-to-rete-object-types)
      (push-to-rete-state init-node t))
;;       (push-to-rete-state nil previous-state))
;;     (setf open-nodes (list node))
    (do* ((stop-this (stop-search node problem) (stop-search node problem)))
	 (stop-this (when-stop (cdr stop-this) node problem))
      
      (trace-search-extras (snode-number node))
      (expand-state node :helpful helpful)
      (when lookahead (expand-for-lookahead node lookahead))

      (print-search-node node nil)
      
;;      (push node (gethash (snode-hash-code node) visited))	     
;;       (when *generate-learning-examples-p* (save-examples node better-h-node nil))
      (if use-rules-p
	  (prune-by-rules node))
      (setf better-h-node (get-enforced-heuristic node h-fn current-h visited :discrete discrete-h 
						  :current-h-plus current-h-plus))
      (cond ((snode-p better-h-node)
	     (setf current-h (snode-h-value better-h-node))
	     (setf current-h-plus (snode-h-plus better-h-node))
	     (setf node better-h-node)
	     (setf open-nodes nil)
	     (setf open-children nil)
 	     (setf visited (reset-hash-visited node))
	     )
	    (t 
	     (setf open-children (nconc (remove-if #'snode-closed (snode-children node)) 
				       open-children))
	     
	     (cond ((not (snode-p (setf next-node (pop open-nodes))))
		    (when (> *say-output* *errt-output-threshold*) (format t "  ~% [Expanding Breadth Level]"))
		    (setf open-nodes (ehc-open-nodes open-children (car (find-argument search-options :children-sort))))
		    
		    (when (null open-nodes) ;;Recuperando la poda por las helpful actions
		      (setf open-nodes (restore-nonhelpful node h-fn))
		      (when (> *say-output* *errt-output-threshold*)
			(format t "  ~%!!Restoring NON Helpful Nodes.")))
		    (setf node (pop open-nodes))
		    (setf open-children nil))
		   (t 
		    (setf node next-node)))))
      ;; Now it is efficient
    (if (and *rete-root-node* (car (find-argument search-options :use-rules-p)))
	(push-to-rete-state node nil))
;; 	(push-to-rete-state previous-state (setq previous-state (pp-state (snode-state node) 'list))))
      ;; 	 (when (snode-p node)
      ;; 	   (print-search-node node nil)
      )))


;; This is the version on top of EHC
(defun errt-ehc (init-node h-function cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let* ((old-goals (problem-goals *current-problem*))
	 (open-nodes nil) (open-children nil)
	 (node init-node) (next-node nil) (visited (make-hash-table))
	 ;; 	 (target nil)
	 ;;	(extend (car (find-argument search-options :extend)))
	 (rrt-random-state (search-option-value :rrt-random-state search-options))
	 (rrt-distance (search-option-value :rrt-distance search-options))
	 (p (search-option-value :p search-options))
	 (r (search-option-value :r search-options))
	 ;; 	(previous-state (pp-state (snode-state init-node) 'list))
	 (use-rules-p (search-option-value :use-rules-p search-options))
	 (lookahead (search-option-value :lookahead search-options))
	 (helpful (search-option-value :helpful search-options))
	 (target-selector (search-option-value :target-selector search-options))
	 (actions (search-option-value :actions search-options))
	 (goal-regression (search-option-value :goal-regression search-options))
;;	 (partial-plan (if *previous-solution* (build-partial-plan *previous-solution*)))
;; 	 (actions (if partial-plan (partial-plan-actions partial-plan)))
;; 	 (goal-regression (if partial-plan (compute-goal-regression partial-plan *previous-solution*)))
	 (tree (list init-node))
	 (current-h 0) (current-h-plus 0) (better-h-node nil) (discrete-h (not (is-metric-domain))))
    (setf *distance-computation* (make-hash-table :test #'equal))
    (setf *computation-avoided* 0)
    (cond (*trace-mem* 
	   (say-consed-bytes :mem-per-node (store-h-extras node h-function))
	   (write-node-mem-info 'errt))
	  (t (store-h-extras node h-function)))
    (setf current-h (snode-h-value node))
    (setf current-h-plus (snode-h-plus node))
    (when (and use-rules-p *rete-root-node*)
      (push-to-rete-goals)
      (push-to-rete-object-types)
      (push-to-rete-state init-node t))
    ;;       (push-to-rete-state nil previous-state))
    ;;     (setf open-nodes (list node))
    (do* ((stop-this (stop-search node problem) (stop-search node problem)))
	(stop-this (setf *errt-tree* tree)
		   (when-stop (cdr stop-this)
			      (if (eq (cdr stop-this) :goals-reached)
				  node
				  (nearest tree old-goals rrt-distance h-function 0))
			      problem))
      (trace-search-extras (snode-number node))
      (multiple-value-bind (target index)
	  (choose-target (pp-state (problem-goals *current-problem*) 'list)
			 rrt-random-state p r goal-regression target-selector actions)
	;;       (setq target (choose-target  (pp-state (problem-goals *current-problem*) 'list)
	;; 				   rrt-random-state p r goal-regression target-selector actions))
	(setf (problem-goals *current-problem*) target)
	(if (not (eq target-selector 'action))
	    (setq node (nearest tree target rrt-distance h-function index)))
	(when (> *say-output* *errt-output-threshold*) (format t "~%Nearest node ~a action ~a" (snode-number node) (snode-applied-action node)))
	;;       (setq node (nearest tree target rrt-distance h-function))
	;; the following is the expansion part of ERRT
	(if use-rules-p (prune-by-rules node))
	(if (not (snode-expanded node)) (expand-state node :helpful helpful))
	(if lookahead (expand-for-lookahead node lookahead))
	(print-search-node node nil)
	;;      (push node (gethash (snode-hash-code node) visited))	     
	;;       (when *generate-learning-examples-p* (save-examples node better-h-node nil))
	(setf better-h-node (choose-next-node node target-selector visited target index h-function actions p r 'errt-ehc current-h current-h-plus discrete-h)))
      ;;      (setf better-h-node (get-enforced-heuristic node h-function current-h visited :discrete discrete-h :current-h-plus current-h-plus))
      (cond ((snode-p better-h-node)
	     (setq nearest better-h-node)
	     (setf current-h (snode-h-value better-h-node))
	     (setf current-h-plus (snode-h-plus better-h-node))
	     (setf node better-h-node)
	     (setf open-nodes nil)
	     (setf open-children nil)
 	     (setf visited (reset-hash-visited node)))
	    (t
	     ;; 	     (dolist (child (snode-children node))
	     ;; 		 (if (not (snode-closed child))
	     ;; 		     (push child open-children)))
	     (setf open-children (nconc (remove-if #'snode-closed (snode-children node)) 
					open-children))
	     (cond ((not (snode-p (setf next-node (pop open-nodes))))
		    (when (> *say-output* *errt-output-threshold*) (format t "  ~% [Expanding Breadth Level]"))
		    (setf open-nodes (ehc-open-nodes open-children (search-option-value :children-sort search-options)))
		    (when (null open-nodes) ;;Recuperando la poda por las helpful actions
		      (setf open-nodes (restore-nonhelpful node h-function))
		      (when (> *say-output* *errt-output-threshold*) 
			(format t "  ~%!!Restoring NON Helpful Nodes.")))
		    (setf node (pop open-nodes))
		    (setf open-children nil))
		   (t (setf node next-node)))
	     (setf (getf (snode-plist node) :expansion-reason) :current-search)))
      (if (> *say-output* *errt-output-threshold*)
	  (format t "~%Best node ~a, action ~a" (snode-number node) (snode-applied-action node)))
      (pushnew node tree)
      (if (and *rete-root-node* use-rules-p)
	  (push-to-rete-state node nil))
      (setf (problem-goals *current-problem*) old-goals))))

;; target-selector can be: goal-regression (all goal-regression of a random node), random (a random subset of goal-regression),
;; preconds (the preconds of a given step), action (select actions instead of goals)
(defun errt-hc (init-node h-function cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let* ((old-goals (problem-goals *current-problem*))
;;	 (extend (search-option-value :extend search-options))
;; 	 (target nil)
	 (rrt-random-state (search-option-value :rrt-random-state search-options))
	 (rrt-distance (search-option-value :rrt-distance search-options))
	 (p (search-option-value :p search-options))
	 (r (search-option-value :r search-options))
	 ;; 	(previous-state (pp-state (snode-state init-node) 'list))
	 (use-rules-p (search-option-value :use-rules-p search-options))
	 (lookahead (search-option-value :lookahead search-options))
	 (target-selector (search-option-value :target-selector search-options))
	 (helpful (search-option-value :helpful search-options))
	 ;; I am not so sure about this
;;	 (helpful (and (not (eq target-selector 'action)) (search-option-value :helpful search-options)))
	 (visited (make-hash-table))
	 (node init-node)
	 (next-node nil)
	 (actions (search-option-value :actions search-options))
	 (goal-regression (search-option-value :goal-regression search-options))
;;	 (partial-plan (if *previous-solution* (build-partial-plan *previous-solution*)))
;; 	 (actions (if partial-plan (partial-plan-actions partial-plan)))
;; 	 (goal-regression (if partial-plan (compute-goal-regression partial-plan *previous-solution*)))
	 (tree (list init-node)))
    (setf *distance-computation* (make-hash-table :test #'equal))
    (setf *computation-avoided* 0)
    (store-h-extras node h-function)
    (when (and use-rules-p *rete-root-node*)
      (push-to-rete-goals)
      (push-to-rete-object-types)
      (push-to-rete-state init-node t))
    ;;       (push-to-rete-state nil previous-state))
    ;;     (setf open-nodes (list node))
    (do* ((stop-this (stop-search node problem) (stop-search node problem)))
	(stop-this (setf *errt-tree* tree)
		   (when-stop (cdr stop-this)
			      (if (eq (cdr stop-this) :goals-reached)
				  node
				  (nearest tree old-goals rrt-distance h-function 0))
			      problem))
      (multiple-value-bind (target index)
	  (choose-target (pp-state (problem-goals *current-problem*) 'list)
			 rrt-random-state p r goal-regression target-selector actions)
	(setf (problem-goals *current-problem*) target)
	(if (not (eq target-selector 'action))
	    (setq node (nearest tree target rrt-distance h-function index)))
	(when (> *say-output* *errt-output-threshold*) (format t "~%Nearest node ~a action ~a" (snode-number node) (snode-applied-action node)))
	;; the following is the expansion part of ERRT
	(if use-rules-p (prune-by-rules node))
	(if (not (snode-expanded node)) (expand-state node :helpful helpful))
	(if lookahead (expand-for-lookahead node lookahead))
	(push node (gethash (snode-hash-code node) visited))
	(setf next-node (choose-next-node node target-selector visited target index h-function actions p r 'errt-hc)))
      (cond ((snode-p next-node)
	     (pushnew next-node tree)
	     (setf node next-node))
	    (t
	     (dolist (i-child (restore-nonhelpful node h-function))
	       (when (find i-child (gethash (snode-hash-code i-child) visited) :test #'equal-state)
		 (setf (snode-closed i-child) t)))
	     (when (> *say-output* 1) (format t "{~% Restoring NON-Helpful Actions!!}"))
;;	     (restore-nonhelpful node h-function)
;;	     (when (> *say-output* *errt-output-threshold*) (format t "{~% Restoring NON-Helpful Actions!!}"))
	     (setf next-node (hc-next-node node t))
	     (pushnew next-node tree)
	     (setf node next-node)
	     (setf (getf (snode-plist node) :expansion-reason) :current-search)))
      (if (> *say-output* *errt-output-threshold*)
	  (format t "~%Best node ~a, action ~a" (snode-number node) (snode-applied-action node)))
      (when (snode-p node)
	(print-search-node node nil))
      (if (and *rete-root-node* use-rules-p)
	  (push-to-rete-state node nil))
      (setf (problem-goals *current-problem*) old-goals))))

;; Returns a new goals hash table and an index on the previous actions
(defun choose-target (goals rrt-random-state p r goal-regression target-selector actions)
  (let ((random (random 1.0)))
    (multiple-value-bind (new-goals index)
	(cond ((or (eq target-selector 'action) (< random p))
	       (values goals 0))
	      ((and (< random (+ p r)) goal-regression)
	       (choose-one-goal goal-regression target-selector actions))
	      (t (values (funcall rrt-random-state goals) (length goal-regression))))
      (if (> *say-output* *errt-output-threshold*) (format t "~2%New goals: ~a" new-goals))
      (values (literalgoals-bitmap new-goals) index))))

;; Returns an index and a random goal regression from one of the actions in the previous plan or the preconds of a previous action or a previous action
(defun choose-one-goal (goal-regression target-selector actions)
  (let ((random 0))
    (case target-selector
      (goal-regression (setq random (1+ (random (1- (length goal-regression)))))
		       (values (elt goal-regression random) random))
      (random (setq random (1+ (random (1- (length goal-regression)))))
	      (let ((goals (elt goal-regression random))
		    (new-goals nil))
		(dotimes (i (random (1- (length goals))))
		  (push (choose-one goals) new-goals)
		  (setq goals (remove (car new-goals) goals :test #'equal)))
		(values new-goals random)))
      (preconds (setq random (1+ (random (1- (length actions)))))
		(values (cadr (elt actions random)) random))
      (otherwise (values nil 0)))))

;; If random < p, EHC.
;; If p < random <r, we compute the intersection of the next actions in the previous plan and the applicable actions.
;; If intersection is empty, we switch to goal-regression based ERRT, in that we select randomly a goal-regression of the previous actions (with greater
;; probability of being the last actions) and an action that goes towards it.
;; If intersection is not empty, with probability 1-(p+r) we do goal-regression based ERRT (with greater probability of being the last actions).
;; And with probability p+r, we select randomly an action from the intersection.
(defun choose-next-node (node target-selector visited target index h-function actions p r algorithm &optional current-h current-h-plus discrete-h)
  (let* ((random (random 1.0))
	 (case-based-p (and (eq target-selector 'action) (>= random p)))
	 (previous-node (if case-based-p (choose-one-action actions node (< random (+ p r)))))
	 (selected-node nil))
    (update-childen algorithm node visited case-based-p previous-node target h-function index)
    (cond ((and case-based-p previous-node)
	   (cond ((snode-closed previous-node)
		  (cond ((and (zerop p) (= r 1.0))
			 ;; since EHC can generate solutions state loops, I still have to select the node to be consistent: the behavior with p=0 and r=1 must
			 ;; be exactly equal to previous solution
			 (setf (snode-closed previous-node) nil)
			 (if (> *say-output* *errt-output-threshold*) (format t "~%Selected a node that was closed"))
			 (setf (getf (snode-plist previous-node) :expansion-reason) :reuse-closed)
			 previous-node)
			((eq algorithm 'errt-ehc)
			 (if (> *say-output* *errt-output-threshold*) (format t "~%Selected best node from current search given that previous node was closed"))
			 (setq selected-node (get-enforced-heuristic node h-function current-h visited :discrete discrete-h :current-h-plus current-h-plus))
			 (return-node selected-node :reuse-closed))
			(t (dolist (i-child (snode-children node))
			     (rrt-distance i-child target h-function index))
			   (if (> *say-output* *errt-output-threshold*) (format t "~%Selected best node from current search given that previous node was closed"))
			   (setq selected-node (hc-next-node node))
			   (return-node selected-node :reuse-closed))))
		 (t (if (> *say-output* *errt-output-threshold*) (format t "~%Selected a node from previous plan"))
		    (return-node previous-node :reuse))))
	  ((eq algorithm 'errt-ehc)
	   (if (> *say-output* *errt-output-threshold*) (format t "~%Selected best node from current search"))
	   (unless current-h
	     (store-h-extras node h-function)
	     (setq current-h (snode-h-value node))
	     (setq current-h-plus (snode-h-plus node)))
	   (setq selected-node (get-enforced-heuristic node h-function current-h visited :discrete discrete-h :current-h-plus current-h-plus))
	   (return-node selected-node :current-search))
	  (t (if (> *say-output* *errt-output-threshold*) (format t "~%Selected best node from current search"))
	     (setq selected-node (hc-next-node node))
	     (return-node selected-node :current-search)))))

;; If random < p, the best h(n). If p < random <r, the next action from previous plan. If not, a random action from previous plan. If the next action or the
;; random action are not children of current node, or they are closed (repeated), then we select the best one
;; (defun choose-next-node (node target-selector visited target index h-function actions p r algorithm &optional current-h current-h-plus discrete-h)
;;   (let* ((random (random 1.0))
;; 	 (case-based-p (and (eq target-selector 'action) (>= random p)))
;; 	 (previous-node (if case-based-p (choose-one-action actions node (< random (+ p r)))))
;; 	 (selected-node nil))
;;     (update-childen algorithm node visited case-based-p previous-node target h-function index)
;;     (cond ((and case-based-p previous-node)
;; 	   (cond ((snode-closed previous-node)
;; 		  (cond ((and (zerop p) (= r 1.0))
;; 			 ;; since EHC can generate solutions state loops, I still have to select the node to be consistent: the behavior with p=0 and r=1 must
;; 			 ;; be exactly equal to previous solution
;; 			 (setf (snode-closed previous-node) nil)
;; 			 (if (> *say-output* *errt-output-threshold*) (format t "~%Selected a node that was closed"))
;; 			 (setf (getf (snode-plist previous-node) :expansion-reason) :reuse-closed)
;; 			 previous-node)
;; 			((eq algorithm 'errt-ehc)
;; 			 (if (> *say-output* *errt-output-threshold*) (format t "~%Selected best node from current search given that previous node was closed"))
;; 			 (setq selected-node (get-enforced-heuristic node h-function current-h visited :discrete discrete-h :current-h-plus current-h-plus))
;; 			 (return-node selected-node :reuse-closed))
;; 			(t (dolist (i-child (snode-children node))
;; 			     (rrt-distance i-child target h-function index))
;; 			   (if (> *say-output* *errt-output-threshold*) (format t "~%Selected best node from current search given that previous node was closed"))
;; 			   (setq selected-node (hc-next-node node))
;; 			   (return-node selected-node :reuse-closed))))
;; 		 (t (if (> *say-output* *errt-output-threshold*) (format t "~%Selected a node from previous plan"))
;; 		    (return-node previous-node :reuse))))
;; 	  ((eq algorithm 'errt-ehc)
;; 	   (if (> *say-output* *errt-output-threshold*) (format t "~%Selected best node from current search"))
;; 	   (unless current-h
;; 	     (store-h-extras node h-function)
;; 	     (setq current-h (snode-h-value node))
;; 	     (setq current-h-plus (snode-h-plus node)))
;; 	   (setq selected-node (get-enforced-heuristic node h-function current-h visited :discrete discrete-h :current-h-plus current-h-plus))
;; 	   (return-node selected-node :current-search))
;; 	  (t (if (> *say-output* *errt-output-threshold*) (format t "~%Selected best node from current search"))
;; 	     (setq selected-node (hc-next-node node))
;; 	     (return-node selected-node :current-search)))))

(defun update-childen (algorithm node visited case-based-p previous-node target h-function index)
  (declare (special *computation-avoided*))
  (if (not (eq algorithm 'errt-ehc))
      (dolist (i-child (snode-children node))
	(cond ((find i-child (gethash (snode-hash-code i-child) visited) :test #'equal-state)
	       (setf (snode-closed i-child) t))
	      ;; I only need to evaluate if random decision selects to make decision according to h(n)
	      ((and case-based-p previous-node) (incf *computation-avoided*))
	      ;; I now have to reevaluate each child node
	      ;; 	(store-h-extras i-child h-function))
	      (t (rrt-distance i-child target h-function index))))))

(defun return-node (node reason)
  (cond ((snode-p selected-node)
	 (setf (getf (snode-plist selected-node) :expansion-reason) reason)
	 selected-node)
	(t reason)))

;; If random > p, then we select one action from the previous solution
;; the probability of choosing the next action (according to the current depth) is 1/2, the 2nd action from where we are is 1/4, and so on
;; the 0 position cannot be selected, since it is the ficticious a0
(defun choose-one-action (actions node next-action-p)
  (if actions
      (let* ((num-actions (1- (length actions)))
	     (action (car (elt actions (min num-actions (if next-action-p
							    (1+ (snode-depth node))
							    (select-random-action (snode-depth node) num-actions)))))))
	;;    (format t "~%action to compare: ~a" action)
	;;    (format t "~%children: ~a" (snode-children node))
	(find-if #'(lambda (child)
		     ;;		 (format t "~%action: ~a" (gaction-planaction (snode-applied-action child)))
		     (equal action (gaction-planaction (snode-applied-action child))))
		 (snode-children node)))))

(defun select-random-action (depth num-actions)
  (do* ((random (random 1.0))
	(i (+ depth 2) (1+ i))
	(inc 0.5 (/ inc 2))
	(acc 0.5 (+ acc inc)))
      ((or (>= i num-actions)
	   (>= acc random))
       i)))

;; I do not see how we can do this easily, unless we select randomly from a subset of preconds of actions in the relaxed plan of the node and then translate into hash table
(defun rrt-random-state (goal)
  goal)

;; The goal is set by the algorithm
;; If it had computed previously the heuristic, it does not recompute it again.
(defun rrt-distance (node goal h-function index)
  (declare (special *distance-computation*))
  (if (snode-closed node)
      most-positive-fixnum
      (let* ((key (cons (snode-number node) index))
	     (previous-computation (gethash key *distance-computation*))
	     (heuristic (car previous-computation))
	     (relaxed-plan (cdr previous-computation)))
	(when (> *say-output* *errt-output-threshold*)
	  (format t "~%Computing distance of node ~a, action ~a~%with goals: ~a" (snode-number node) (snode-applied-action node) (pp-state goal 'list))
	  (format t "~%Node: ~d; goal: ~d; h: ~d" (snode-number node) index previous-computation))
	(cond (previous-computation (incf *computation-avoided*)
				    (setf (snode-h-value node) heuristic)
				    (setf (snode-h-plus node) (length relaxed-plan))
				    (setf (snode-relaxed-plan node) relaxed-plan)
				    (if (> *say-output* *errt-output-threshold*) (format t "~%Avoided a computation")))
	      (t (store-h-extras node h-function)
		 (setq heuristic (snode-h-value node))
		 (setf (gethash key *distance-computation*) (cons heuristic (snode-relaxed-plan node)))
		 (if (> *say-output* *errt-output-threshold*) (format t "~%Result: ~a" heuristic))))
	heuristic)))

;; (defun rrt-distance (node goal h-function)
;;   (incf (get (problem-plist *current-problem*) :node-evaluated))
;;   (let ((goals (problem-goals *current-problem*))
;; 	(heuristic most-positive-fixnum))
;;      (setf (problem-goals *current-problem*) goal)
;;     (setq heuristic (funcall h-function node))
;;      (setf (problem-goals *current-problem*) goals)
;;     heuristic))
  
(defun nearest (tree target rrt-distance h-fn index)
  (let ((nearest nil)
	(distance most-positive-fixnum)
	(new-distance))
    (dolist (node tree)
      (setq new-distance (funcall rrt-distance node target h-fn index))
      (when (< new-distance distance)
	(setq nearest node)
	(setq distance new-distance)))
    nearest))

;; Modified so that it gets rid of state loops
;; (defun build-path (node &optional (smoothing-p t))
;;   (do* ((i-node node (snode-parent i-node))
;; 	(later-node nil (and smoothing-p (find i-node plan-path :test #'equal-state)))
;; 	(plan-path nil))
;;       ((null (snode-parent i-node))
;;        plan-path)
;;     (when later-node
;;       (do ((middle-node (snode-selected i-node) (snode-selected middle-node)))
;; 	  ((or (null middle-node) (eq middle-node (snode-selected later-node))))
;; 	(pop plan-path))
;;       (setf (snode-selected i-node) (snode-selected later-node)))
;;     (setf (snode-selected (snode-parent i-node)) i-node)
;;     (push i-node plan-path)))

;;	(format t "~%Removing action from plan: ~a" (snode-applied-action middle-node))
;;    (format t "~%Node: ~a~%Later-node: ~a~%Plan: ~a" i-node later-node plan-path)
;;    (format t "~%State: ~a" (give-me-nice-sayphi-state i-node))
;;    (format t "~%Selected-of-node: ~a" (snode-selected i-node)))

;; DB. Modified so that it accounts well for removing state loops
(defun build-solution (node problem found reason)
  (let* ((stop-time (get-internal-run-time))
	 (initial-pre-time (get (problem-plist problem) :initial-pre-time))
	 (initial-search-time (get (problem-plist problem) :initial-search-time))
	 (this-solution (make-solution 
			 :found found
			 :total-time (float (/ (- stop-time initial-pre-time)
					       internal-time-units-per-second))
			 :pre-time (float (/ (- initial-search-time initial-pre-time)
					     internal-time-units-per-second))
			 :search-time (float (/ (- stop-time initial-search-time)
						internal-time-units-per-second))
			 :depth (when (snode-p node) (snode-depth node))
			 :path (when (snode-p node) (build-path node))
			 :num-nodes (1+ (get (problem-plist problem) :node-counter)) ;;mas el nodo inicial
			 :evaluated-nodes (get (problem-plist problem) :node-evaluated)
			 :last-node node
			 :stop-reason reason)))
    (setf (solution-length this-solution)
	  (when (snode-p node) (compute-solution-length (solution-path this-solution))))
    (setf (solution-total-cost this-solution)
	  (when (snode-p node) (compute-total-cost node problem (solution-length this-solution))))
    this-solution))

;; The default is the length of the solution-path, but in lookaheads we have to compute the length of lookahead plans
(defun compute-solution-length (path)
  (let ((length 0))
    (dolist (i-node path length)
      (cond ((lhnode-p i-node) 
	     (setf length (+ length (lhnode-lookahead-depth i-node))))
	    (t (incf length))))))

(defun compute-total-cost (node problem length)
  (let ((metric (problem-metric problem))
	(last-state (snode-state node)))
    (cond ((null metric) length)
	  (t
	   ;; this should be recomputed?
	   (operand-funeval (cadr metric) last-state nil)))))

(defun plan (&key (algorithm nil)
		  (heuristic nil)
		  (cost *say-costfn*)
		  (timeout *say-timeout*)
		  (depthbound *say-depthbound*)
		  (helpful *say-helpful*)
		  (w_g nil)
		  (w_h nil)
		  (max-solutions most-positive-fixnum)
		  (rules-file nil)
		  (use-rules-p nil)
		  (lookahead nil)
		  (search-options nil)
		  (try2-search *say-2try*))
  (declare (special *current-problem*)
	   (ignore try2-search))
  (let ((problem *current-problem*)
	(i-node nil)
	(algorithm-fn (if algorithm (symbol-function algorithm) (say-plan-defaults 'algorithm)))
	(heuristic-fn (if heuristic (symbol-function heuristic) (say-plan-defaults 'heuristic)))
	(cost-fn (symbol-function cost))
	(start-time (get-internal-run-time))
	(sol nil))
    (set-sayp :say-timeout timeout)
    (set-sayp :say-depthbound depthbound)

    (reset-ehc-trace)
    (sayout-initialize)
    (set-duplicate-hashing)
    (setf i-node (initialize-current-problem))

    (setf (get (problem-plist problem) :initial-pre-time) start-time)
    (setf (get (problem-plist problem) :initial-search-time) (get-internal-run-time))
    
    (setf  *search-failed* nil)

    ;; this is DB trying to do sme debugging and accessing tree
;;    (setf *top-level-node* i-node)
    ;; this is needed for ERRT
;;    (setf *previous-solution* (if *say-solution* (solution-path *say-solution*)))

    (setf *say-solution* nil)

    ;; Loads the control rules from the file and builds the rete net
    (when (and use-rules-p rules-file)
      (load-rules-build-rete rules-file)
      (push (list :use-rules-p t) search-options))
    
    (push (list :helpful helpful) search-options)
    (when (numberp max-solutions)
      (push (list :max-solutions max-solutions) search-options))
    (when  w_g (push (list :w_g w_g) search-options))
    (when w_h (push (list :w_h w_h) search-options))
 
    (when lookahead
      (push (list :lookahead lookahead) search-options))
    (sayout-search t algorithm heuristic cost)
    (setf sol (funcall algorithm-fn i-node heuristic-fn cost-fn search-options))

    ;;     Turning to best-first algorithm without helpful actions
    ;;     (cond ((and *search-failed* try2-search)
    ;; 	   (setf i-node (initialize-current-problem))
    ;; 	   (setf sol (best-first i-node heuristic-fn cost-fn)))
    ;; 	  (t sol))

    ))

(defun runset (domain domain-file &key (algorithm nil) (heuristic nil) (cost *say-costfn*)  (max-solutions most-positive-fixnum) (helpful *say-helpful*)
	              (w_g nil) (w_h nil) (timeout 5) (output-level 1) (depthbound 3000) (metric nil) (probs-prefix "p") (save-result t) (out-file nil) (try2-search t)
		      (experiment-var nil) (say-learning-p nil) (rules-file nil) (use-rules-p nil) (init-learning-p nil) (search-options nil))
  (declare (ignore metric))
  (setf *say-output* output-level)
  (say-domain domain domain-file)
  (let* ((probdir (format nil "~aprobsets/" *domain-dir*))
	 (count-prob 1) (this-sol nil)
	 (result-file (if (stringp out-file)
			  (format nil "~aresult/~a" *domain-dir* out-file)
			  (format nil "~aresult/~a-~a-~a-~d-~a-~a.csv"
				  *domain-dir* probs-prefix algorithm heuristic timeout
				  (search-option-value :target-selector search-options) (search-option-value :algorithm search-options))))
	 (wild-char #+SBCL "*.*"
		    #-SBCL "*"))
    (with-open-file (out-stream result-file :direction :output :if-exists :supersede :if-does-not-exist :create)
      (format out-stream "Prob,Algorithm,P,R,Name,Found,Time,Length,Nodes,Evaluations,Cost,Reason,Avoided,Reuse-closed,Reuse,Current-search~%"))
    (dolist (thisprob (dirfiles-sorted probdir (concatenate 'string probs-prefix wild-char)))
      (setq this-sol (or (pop (search-option-value :initial-solutions search-options))
			 (solve-problem thisprob algorithm try2-search heuristic cost timeout depthbound helpful w_g w_h max-solutions
					rules-file use-rules-p search-options save-result count-prob experiment-var say-learning-p result-file)))
      (when (search-option-value :use-errt search-options)
	(if (eq (search-option-value :modify-problem search-options) 'from-probset)
	    (setf *modified-probset* (dirfiles-sorted probdir (concatenate 'string (search-option-value :modified-probset search-options) wild-char))))
	(errt-solve domain domain-file algorithm heuristic cost max-solutions helpful w_g w_h timeout depthbound save-result try2-search experiment-var say-learning-p result-file
		    rules-file use-rules-p search-options count-prob this-sol (search-option-value :p search-options) (search-option-value :r search-options)
		    (remove-if #'(lambda (option) (or (eq (car option) :p) (eq (car option) :r))) search-options) thisprob))
      (setf this-sol nil)
      (free-mem)
      (incf count-prob))))

(defun errt-solve (domain domain-file algorithm heuristic cost max-solutions helpful w_g w_h timeout depthbound save-result try2-search experiment-var say-learning-p result-file
			  rules-file use-rules-p search-options count-prob this-sol p r new-search-options thisprob)
  (when (or (stringp this-sol) (pathnamep this-sol))
    (with-open-file (istream this-sol :direction :input) (setq this-sol (read istream)))
    (load-prob thisprob))
  (let ((previous-sol (if (listp this-sol) this-sol (solution-found this-sol))))
    (unless previous-sol
      (setq previous-sol nil)
      (free-mem)
      (setq this-sol (find-solvable-problem thisprob domain domain-file search-options algorithm try2-search heuristic cost timeout depthbound helpful w_g w_h max-solutions
					    rules-file use-rules-p save-result count-prob experiment-var say-learning-p result-file 0 p r)))
    (if this-sol
	(let* ((solution (if (listp this-sol) this-sol (solution-path this-sol)))
	       (partial-plan (build-partial-plan solution))
	       (actions (if partial-plan (partial-plan-actions partial-plan)))
	       (goal-regression (if partial-plan (compute-goal-regression partial-plan solution)))
	       (just-actions nil)
	       (new-prob nil))
	  (dotimes (i (length actions))
	    (push (car (aref actions i)) just-actions))
	  (setq just-actions (reverse just-actions))
	  ;;		 (sayphi-sol this-sol)
	  ;; for efficiency purposes
	  (setq this-sol nil)
	  (dotimes (i (if (eq (search-option-value :modify-problem search-options) 'from-probset)
			  (length *modified-probset*)
			  (search-option-value :max-modifications search-options)))
	    (setq new-prob (if previous-sol
			       (modify-problem (search-option-value :modify-problem search-options) domain thisprob i (search-option-value :max-goals search-options) just-actions)
			       thisprob))
	    (when new-prob
	      ;; so that we have an execution of Sayphi with the new problem
	      (solve-problem new-prob algorithm try2-search heuristic cost timeout depthbound helpful w_g w_h max-solutions
			     rules-file use-rules-p search-options save-result count-prob experiment-var say-learning-p result-file)
	      (push (list :goal-regression goal-regression) new-search-options)
	      (push (list :actions actions) new-search-options)
	      ;; now, we solve it N times with ERRT
	      (dolist (prob-p (if (listp p) p (list p)))
		(dolist (prob-r (if (listp r) r (list r)))
		  ;; p=1, r=0 is the same as EHC
		  (if (and (<= (+ prob-p prob-r) 1.0)
			   (not (and (= prob-p 1.0) (= prob-r 0.0))))
		      ;; p=0, r=1 is not stochastic
		      (dotimes (i (if (and (= prob-p 0.0) (= prob-r 1.0)) 1 (search-option-value :number-repetitions new-search-options)))
			;;		      (setf *say-solution* sayphi-sol)
			(push (list :p prob-p) new-search-options)
			(push (list :r prob-r) new-search-options)
			(format t "~% Solving problem ~a with ~a, p=~d, r=~d" (pathname-name new-prob) (search-option-value :algorithm new-search-options) prob-p prob-r)
			(setq this-sol (plan :algorithm (search-option-value :algorithm new-search-options) :search-options new-search-options))
			(if (> *say-output* *errt-output-threshold*) (print this-sol))
			(print-result-file save-result result-file count-prob new-prob (search-option-value :algorithm new-search-options) this-sol
					   *computation-avoided* prob-p prob-r)
			(setq this-sol nil)
			(free-mem)
			(load-prob new-prob))))))
	    ;; so that it modifies not the new one, but the original one
	    (load-prob thisprob))))))

(defun find-solvable-problem (thisprob domain domain-file search-options algorithm try2-search heuristic cost timeout depthbound helpful w_g w_h max-solutions
				       rules-file use-rules-p save-result count-prob experiment-var say-learning-p result-file i p r)
  (if (<= i (search-option-value :max-relaxations search-options))
      (let* ((new-problem (modify-problem 'relax-problem domain thisprob i (search-option-value :max-goals search-options) nil))
	     (new-solution (solve-problem new-problem algorithm try2-search heuristic cost timeout depthbound helpful w_g w_h max-solutions
					  rules-file use-rules-p search-options save-result count-prob experiment-var say-learning-p result-file)))
	(cond ((solution-found new-solution) new-solution)
	      (t (setq new-solution nil)
		 (free-mem)
		 ;; I give FF an opportunity, given in some domains Sayphi says that there are unreachable goals, when it is not the case
		 (setf *ff-output-directory* (concatenate 'string *domains-dir* domain "/"))
		 (format t "~% Solving problem ~a with Metric-FF" (pathname-name new-problem))
		 (execute-ff :domain-file domain-file :problem-file (concatenate 'string "probsets/" new-problem))
		 (setq new-solution (car (solutions-ff)))
		 (cond (new-solution)
		       (t (setq new-solution (find-solvable-problem new-problem domain domain-file search-options algorithm try2-search heuristic cost timeout depthbound
								    helpful w_g w_h max-solutions
								    rules-file use-rules-p save-result count-prob experiment-var say-learning-p result-file (1+ i) p r))
			  (if (and new-solution (solution-found new-solution))
			      (do* ((partial-plan (build-partial-plan (solution-path new-solution)))
				    (actions (if partial-plan (partial-plan-actions partial-plan)))
				    (goal-regression (if partial-plan (compute-goal-regression partial-plan (solution-path new-solution))))
				    (prob-p (if (listp p) p (list p)) (cdr prob-p))
				    (solution nil))
				  ((or (null prob-p) (and solution (solution-found solution)))
				   (or solution (find-solvable-problem thisprob domain domain-file search-options algorithm try2-search heuristic cost timeout depthbound
								       helpful w_g w_h max-solutions
								       rules-file use-rules-p save-result count-prob experiment-var say-learning-p result-file (1+ i) p r)))
				(do* ((prob-r (if (listp r) r (list r)) (cdr prob-r)))
				    ((or (null prob-r) (and solution (solution-found solution))))
				  (when (and (<= (+ (car prob-p) (car prob-r)) 1.0)
					     (not (and (= (car prob-p) 1.0) (= (car prob-r) 0.0))))
				    (setq solution nil)
				    (setq new-solution nil)
				    (free-mem)
				    ;;		     (setf *say-solution* new-solution)
				    (load-prob thisprob)
				    (setq search-options (remove-if #'(lambda (apair) (or (eq (car apair) :p) (eq (car apair) :r))) search-options))
				    (push (list :p (car prob-p)) search-options)
				    (push (list :r (car prob-r)) search-options)
				    (pushnew (list :goal-regression goal-regression) search-options :test #'equal)
				    (pushnew (list :actions actions) search-options :test #'equal)
				    (format t "~% Solving problem ~a with ~a, p=~a, r=~a" (pathname-name new-problem) (search-option-value :algorithm search-options)
					    (car prob-p) (car prob-r))
				    (setq solution (plan :algorithm (search-option-value :algorithm search-options) :search-options search-options))
				    (if (> *say-output* *errt-output-threshold*) (print solution))
				    (print-result-file save-result result-file count-prob new-problem
						       (search-option-value :algorithm search-options) solution *computation-avoided* (car prob-p) (car prob-r)))))))))))))
;; (setq new-solution nil)
;; (free-mem)
  
(defun solve-problem (thisprob algorithm try2-search heuristic cost timeout depthbound helpful w_g w_h max-solutions
			       rules-file use-rules-p search-options save-result count-prob experiment-var say-learning-p result-file)
  (format t "~% Solving problem ~a with ~a" (pathname-name thisprob) algorithm)
  (load-prob thisprob)
  (let ((this-sol (plan :algorithm algorithm :try2-search try2-search
					     :heuristic heuristic :cost cost 
					     :timeout timeout :depthbound depthbound
					     :helpful helpful :w_g w_g :w_h w_h
					     :max-solutions max-solutions
					     :rules-file rules-file :use-rules-p use-rules-p
					     :search-options search-options)))
    (if (> *say-output* *errt-output-threshold*) (print this-sol))
    (print-result-file save-result result-file count-prob thisprob algorithm this-sol 0)
    (when experiment-var
      (push (list-solution count-prob (pathname-name thisprob) this-sol) 
	    (gethash experiment-var *experiment-results*)))
    ;;       The function execute-learner must be redefined in the learner file
    (when say-learning-p (execute-learner))
    this-sol))

(defun load-prob (prob)
  (read-pddl-problem prob)
  (setf *complete-problem-file* (concatenate 'string (pathname-name prob) "." (pathname-type prob)))
  (setf *problem-file* (pathname-name prob))
  (setf *problem-dir* "probsets/"))

(defun free-mem nil
  (when *print-all-mem*
    (format t "~%Before~%")
    (room nil))
  (say-mem-free-pointers)
  #+SBCL (sb-ext:gc :full t)
  (when *print-all-mem*
    (format t "~%After~%")
    (room nil)))

;; how can be: add-goal, modify-state, relax-problem, remove-constrain, add-constrain,...
(defun modify-problem (how domain problem count max-goals actions)
  (declare (special *current-problem*))
  (if (not *current-problem*) (load-prob problem))
  (let ((name (problem-name *current-problem*))
	(instances (sayphi-problem-objects *current-problem*))
	(state (problem-lit-init-state *current-problem*))
	(goals (problem-lit-goals *current-problem*))
	(metric (problem-metric *current-problem*))
	(new-problem (format nil "~aprobsets/mod~d-~a" *domain-dir* count (pathname-name problem))))
    ;; change here the problem
    (case how
      (from-probset nil)
      (relax-problem (setq goals (remove (choose-one goals) goals :test #'equal)))
      (add-goal (case (read-from-string domain)
		  (blocksworld (let* ((max-index ;; (car (sort (butlast instances 2) #'string>)))
				       (apply #'max (mapcar #'(lambda (block) (read-from-string (string-trim '(#\b #\B) block))))))
				      (max-block (read-from-string (format nil "B~d" max-index)))
				      (previous-block (read-from-string (format nil "B~d" (1- max-index))))
				      (next-block (read-from-string (format nil "B~d" (1+ max-index)))))
				 (format t "~%Next block: ~a" next-block)
				 (push next-block instances)
				 (setq state (remove `(on-table ,previous-block) state :test #'equal))
				 (setq state (remove `(clear ,max-block) state :test #'equal))
				 (push `(on ,previous-block ,max-block) state)
				 (push `(on-table ,next-block) state)
				 (push `(clear ,next-block) state)
				 (push `(on ,max-block ,next-block) goals)))
		  (driverlog-num (let* ((instances-list (process-instances instances))
					(packages (cdr (assoc 'obj instances-list)))
					(trucks (cdr (assoc 'truck instances-list)))
					(drivers (cdr (assoc 'driver instances-list)))
					(locations (cdr (assoc 'location instances-list)))
					(package-not-in-goal t)
					(truck-not-in-goal t)
					(driver-not-in-goal t)
					(max-index 0)
					(new-package 0))
				   (dotimes (i (max 1 (random max-goals)))
				     (cond ((and package-not-in-goal (setq package-not-in-goal (find-if-not #'(lambda (package) (member package goals :test #'member)) packages)))
					    (push `(at ,package-not-in-goal ,(choose-one-location 'link state)) goals))
					   ((and truck-not-in-goal (setq truck-not-in-goal (find-if-not #'(lambda (truck) (member truck goals :test #'member)) trucks)))
					    (push `(at ,truck-not-in-goal ,(choose-one-location 'link state)) goals))
					   ((and driver-not-in-goal (setq driver-not-in-goal (find-if-not #'(lambda (driver) (member driver goals :test #'member)) drivers)))
					    (push `(at ,driver-not-in-goal ,(choose-one-location 'path state)) goals))
					   (t (setq max-index (apply #'max (mapcar #'(lambda (package) (read-from-string (string-trim '(#\P #\A #\C #\K #\G #\E) package)))
										   packages)))
					      (setq new-package (read-from-string (format nil "PACKAGE~d" (1+ max-index))))
					      (push new-package (cdr (assoc 'obj instances-list)))
					      (push `(at ,new-package ,(choose-one-location 'link state)) state)
					      (push `(at ,new-package ,(choose-one-location 'link state)) goals))))
				   (setq instances (flatten-instances instances-list))))
		  ((rovers rovers-num) (let* ((instances-list (process-instances instances))
					      (waypoints (cdr (assoc 'waypoint instances-list)))
					      (objectives (cdr (assoc 'objective instances-list)))
					      (cameras (cdr (assoc 'camera instances-list)))
					      (modes (cdr (assoc 'mode instances-list)))
					      (waypoint-not-in-goal nil)
					      (mode nil)
					      (camera nil)
					      (max-index 0)
					      (new-objective 0)
					      (random-goal (random 4.0)))
					 (dotimes (i (max 1 (random max-goals)))
					   (cond ((and (< random-goal 1)
						       (setq waypoint-not-in-goal
							     (choose-one (remove-if #'(lambda (waypoint)
											(or (member waypoint goals :test #'member)
											    (not (member waypoint state
													 :test #'(lambda (waypoint literal)
														   (and (eq (car literal) 'at_soil_sample)
															(eq (caddr literal) waypoint)))))))
										    waypoints))))
						  (push `(communicated_soil_data ,waypoint-not-in-goal) goals))
						 ((and (< random-goal 2)
						       (setq waypoint-not-in-goal
							     (choose-one (remove-if #'(lambda (waypoint)
											(or (member waypoint goals :test #'member)
											    (not (member waypoint state
													 :test #'(lambda (waypoint literal)
														   (and (eq (car literal) 'at_rock_sample)
															(eq (caddr literal) waypoint)))))))
										    waypoints))))
						  (push `(communicated_rock_data ,waypoint-not-in-goal) goals))
						 ((and (< random-goal 3)
						       (setq objective-not-in-goal (find-if-not #'(lambda (objective) (member objective goals :test #'member)) objectives)))
						  (push `(communicated_image_data ,objective-not-in-goal ,(setq mode (choose-one modes))) goals)
						  (setq camera (cadar (member objective-not-in-goal state :test #'(lambda (objective literal)
														    (and (eq (car literal) 'calibration_target)
															 (eq (caddr literal) objective-not-in-goal))))))
						  (if (not camera)
						      (push `(calibration_target ,(setq camera (choose-one cameras)) ,objective-not-in-goal) state))
						  (pushnew `(supports ,camera ,mode) state :test #'equal))
						 (t (setq max-index (apply #'max (mapcar #'(lambda (objective)
											     (read-from-string (string-trim '(#\O #\B #\J #\E #\C #\T #\I #\V) objective)))
											 objectives)))
						    (setq new-objective (read-from-string (format nil "OBJECTIVE~d" (1+ max-index))))
						    (push new-objective (cdr (assoc 'objective instances-list)))
						    (dolist (waypoint waypoints)
						      (push `(visible_from ,new-objective ,waypoint) state))
						    (push `(calibration_target ,(setq camera (choose-one cameras)) ,new-objective) state)
						    (push `(communicated_image_data ,new-objective ,(setq mode (choose-one modes))) goals)
						    (pushnew `(supports ,camera ,mode) state :test #'equal))))
					 (setq instances (flatten-instances instances-list))))
		  (otherwise nil)))
      (modify-state (case (read-from-string domain)
		      (driverlog-num (let ((walk-actions nil)
					   (drive-actions nil)
					   (random-action nil))
				       (dolist (action (butlast (cdr actions)))
					 (case (car action)
					   (walk (push action walk-actions))
					   (drive-truck (push action drive-actions))
					   (otherwise nil)))
				       (cond ((and (< (random 1.0) 0.5) walk-actions)
					      (setq random-action (choose-one walk-actions))
					      (setq state (remove-if #'(lambda (literal)
									 (and (eq (car literal) 'path)
									      (eq (cadr literal) (caddr random-action))
									      (eq (caddr literal) (cadddr random-action))))
								     state)))
					     (t (setq random-action (choose-one drive-actions))
						(setq state (remove-if #'(lambda (literal)
									   (and (eq (car literal) 'link)
										(eq (cadr literal) (caddr random-action))
										(eq (caddr literal) (cadddr random-action))))
								       state))))))
		      (blocksworld (let* ((blocks (butlast instances 2))
					  (max-index (apply #'max (mapcar #'(lambda (block) (read-from-string (string-trim '(#\b #\B) block)))
									  blocks)))
					  (one-block (choose-one blocks))
					  (on-table-p (member `(on-table ,one-block) state))
					  (block-above (block-above block state))
					  (block-below (block-below block state)))
				     (format t "~%Block to move: ~a; go-up-p: ~a" one-block go-up-p)
				     (cond (on-table-p
					    (cond (block-above (setq state (remove `(on-table ,one-block) state :test #'equal))
							       (setq state (remove `(on ,block-above ,one-block) state :test #'equal))
							       (push `(on ,one-block ,block-above) state)
							       (if (member `(clear ,block-above) state)
								   (push `(clear ,one-block) state)
								   (push `(on ,(cadr (block-above block-above state)) ,one-block) state)))
						  (t (setq top-block (cadr (find (lambda (literal) (and (eq (car literal) 'clear) (not (eq (cadr literal) one-block))) state))))
						     (setq state (remove `(on-table ,one-block) state :test #'equal))
						     (setq state (remove `(clear ,top-block) state :test #'equal))
						     (push `(on ,one-block ,top-block) state))))
					   (t (cond (block-above (setq state (remove `(on ,one-block ,block-below) state :test #'equal))
								 (setq state (remove `(on ,block-above ,one-block) state :test #'equal))
								 (push `(on ,one-block ,block-above) state)
								 (push `(on ,block-above ,block-below) state)
								 (if (member `(clear ,block-above) state)
								     (push `(clear ,one-block) state)
								     (push `(on ,(cadr (block-above block-above state)) ,one-block) state)))
						    (t (setq top-block (cadr (find (lambda (literal) (and (eq (car literal) 'clear) (not (eq (cadr literal) one-block))) state))))
						       (setq state (remove `(on-table ,one-block) state :test #'equal))
						       (setq state (remove `(clear ,top-block) state :test #'equal))
						       (push `(on ,one-block ,top-block) state)))))))
		      (otherwise nil)))
      (otherwise nil))
    (cond ((eq how 'from-probset) (pop *modified-probset*))
	  (t (write-pddl-file name domain instances state goals new-problem metric)
	     new-problem))))

(defun choose-one-location (arc-type state)
  (caddr (choose-one (remove-if-not #'(lambda (literal) (eq (car literal) arc-type)) state))))
    

(defun block-above (block state)
  (cadr (find (lambda (literal) (and (eq (car literal) 'on) (eq (caddr literal) block))) state)))

(defun block-below (block state)
  (caddr (find (lambda (literal) (and (eq (car literal) 'on) (eq (cadr literal) block))) state)))
  
(defun sayphi-problem-objects (problem)
  (let ((result nil))
    (maphash #'(lambda (key val)
		 (setq result `(,@result ,@(reverse (cons key (cons '- val))))))
	     (problem-objects problem))
    result))

;; modify-problem: add-goal, modify-state, from-probset (needs :modified-probset prefix definition)
;; max-relaxations: number of times it will try to relax the unsolvable problem to find a solvable one to reuse from
;; max-modifications: number of times it will complicate the problem, given that problems are randomly complicated
;; number-repetitions: number of experiments of ERRT for each configuration, given that it is stochastic
;; max-goals: how many goals are added eveytime I complicate a problem
;; initial-solutions: list of previous solutions to all problems in the probset specified by prefix. Solutions can be either lists of actions or paths to files with solutions
(defun daniel-plan (&key (domain "driverlog-num") (domain-file "driverlogNum.pddl") (prefix "pfile")
			 (sayphi-algorithm 'enforced-hill-climbing) (algorithm 'errt-ehc) (helpful *say-helpful*)
			 (p (list 0.0 0.3 0.7 1.0)) (r (list 0.0 0.3 0.7 1.0)) (target-selector 'action)
			 (number-repetitions 5) (max-relaxations 10) (max-modifications 5) (max-goals 3) (modify-problem 'add-goal)
			 (modified-probset-prefix "pfile-") (initial-solutions nil))
  (runset domain domain-file
	  :algorithm sayphi-algorithm
	  :probs-prefix prefix
	  :timeout *say-timeout*
	  :helpful helpful
	  :output-level 0
	  :search-options `((:use-errt t) (:number-repetitions ,number-repetitions) (:algorithm ,algorithm)
			    (:max-modifications ,max-modifications) (:max-goals ,max-goals) (:modified-probset ,modified-probset-prefix)
			    (:modify-problem ,modify-problem)  (:max-relaxations ,max-relaxations)
			    (:rrt-random-state ,#'rrt-random-state) (:rrt-distance ,#'rrt-distance)
			    (:p ,p) (:r ,r) (:target-selector ,target-selector) (:initial-solutions ,initial-solutions))))

(defun solution-print (solution stream z)
  (declare (type solution solution)
	   (stream stream)
	   (ignore z))
  (format stream "~%#<SOLUTION: ~a  " (solution-found solution))
  (format stream "~%       Length     : ~d " (solution-length solution))
  (format stream "~%       Nodes      : ~d " (solution-num-nodes solution))
  (format stream "~%       Evaluated  : ~d" (solution-evaluated-nodes solution))
  (format stream "~%       Total time : ~d" (solution-total-time solution))
;;  (format stream "~%       Instantiating Time: ~d" (solution-pre-time solution))
;;  (format stream "~%       Search Time       : ~d" (solution-search-time solution))
;;  (format stream "~%       Metric            : ~a" (problem-metric *current-problem*))
;;  (format stream "~%       Depth            : ~a" (solution-depth solution))
  (format stream "~%       Total cost : ~a >" (solution-total-cost solution))
  )

(defun print-result-file (save-result result-file count-prob new-prob algorithm this-sol computation-avoided &optional (p 1.0) (r 0.0))
  (declare (special *print-reuse*))
  (if save-result
      (let ((number-reuse-closed 0)
	    (number-reuse 0)
	    (number-current-search 0)
	    (errt-p (or (eq algorithm 'errt-ehc) (eq algorithm 'errt-hc))))
	(with-open-file (out-stream result-file :direction :output :if-exists :append :if-does-not-exist :create)
	   (format out-stream (case *say-solution-format*
				(:values "~d, ~a, ~a, ~a, ~a")
				(:list "(~d ~a ~a ~a ~a")
				(:tags-values "NumProb: ~d Prob: ~a Algorithm: ~a P: ~a R: ~a "))
		   count-prob (pathname-name new-prob) algorithm p r)
	  (dolist (node (solution-path this-sol))
	    (case (getf (snode-plist node) :expansion-reason)
	      (:reuse-closed (incf number-reuse-closed) (if (and *print-reuse* errt-p) (format out-stream "RC,")))
	      (:reuse (incf number-reuse) (if (and *print-reuse* errt-p) (format out-stream "R,")))
	      (:current-search (incf number-current-search) (if (and *print-reuse* errt-p) (format out-stream "C,")))
	      (t (if errt-p (format t "~%Something happened"))
		 (if (and *print-reuse* errt-p) (format out-stream "C,"))
		 (incf number-current-search))))
	   (format out-stream (case *say-solution-format*
				(:values ", ~a, ~a, ~a, ~a, ~a~%")
				(:list " ~a ~a ~a ~a ~a)~%")
				(:tags-values "Solution:~a Avoided: ~a Reuse-closed: ~a Reuse: ~a Current-search: ~a~%"))
		   (format-solution this-sol) computation-avoided number-reuse-closed number-reuse number-current-search)))))

(defun format-solution (solution)
  (format nil (case *say-solution-format*
		(:values "~t~a, ~t~4$, ~t~a, ~t~a, ~t~a, ~t~a, ~t~a")
		(:list " ~a ~4$ ~a ~a ~a ~a ~a")
		(:tags-values " Found:~a Time:~a Nodes:~a Evaluated:~d Cost:~a Reason:~a"))
	  (solution-found solution) (solution-total-time solution)
	  (solution-length solution) (solution-num-nodes solution) (solution-evaluated-nodes solution)
	  (solution-total-cost solution) (solution-stop-reason solution)))

(defun summary-results (results-file &key (domain "driverlog-num") (p (list 0.0 0.3 0.7 1.0)) (r (list 0.0 0.3 0.7 1.0)) (number-repetitions 5) (number-modifications 5)
				     (output-file (concatenate 'string *domains-dir* domain "/result/errt-results.csv")))
  (let ((the-results nil))
    (with-open-file (istream results-file :direction :input)
      (setq the-results (read istream)))
    (with-open-file (ostream output-file :direction :output :if-exists :supersede :if-does-not-exist :create)
      (do* ((solved 0) (nodes 0) (time 0) (cost 0) (length 0) (evaluations 0) (reuse-closed 0) (reuse 0) (current-search 0)
	    (i 0 (1+ i))
	    (results (cddr the-results) (if (zerop (mod i number-modifications)) (cdr results) results))
	    (ehc-sol nil) (errt-sol nil)
	    (sayphi-algorithm nil) (algorithm nil)
	    (repetitions 0))
	  ((null results))
	(setq ehc-sol (pop results))
	(setq sayphi-algorithm (or sayphi-algorithm (nth 2 ehc-sol)))
	(cond ((nth 5 ehc-sol)
	       (format ostream "~%~d, ~d, 1.0, 0.0, 1, ~2$, ~4$, ~d, ~d, ~d, 0, 0, ~d" i sayphi-algorithm
		       (nth 10 ehc-sol) (nth 6 ehc-sol) (nth 7 ehc-sol) (nth 8 ehc-sol) (nth 9 ehc-sol) (nth 7 ehc-sol)))
	      (t (format ostream "~%~d, ~d, 1.0, 0.0, 0, 0, 0, 0, 0, 0, 0, 0, 0" i sayphi-algorithm)))
	(dolist (prob-p (if (listp p) p (list p)))
	  (dolist (prob-r (if (listp r) r (list r)))
	    (when (and (<= (+ prob-p prob-r) 1.0)
		       (not (and (= prob-p 1.0) (= prob-r 0.0))))
	      (setq solved 0 nodes 0 time 0 cost 0 length 0 evaluations 0 reuse-closed 0 reuse 0 current-search 0
		    repetitions (if (and (= prob-p 0.0) (= prob-r 1.0)) 1 number-repetitions))
	      (dotimes (i repetitions)
		(setq errt-sol (pop results))
		(setq algorithm (or algorithm (nth 2 errt-sol)))
		(when (nth 5 errt-sol)
		  (incf solved)
		  (incf cost (nth 10 errt-sol))
		  (incf length (nth 7 errt-sol))
		  (incf time (nth 6 errt-sol))
		  (incf nodes (nth 8 errt-sol))
		  (incf evaluations (nth 9 errt-sol))
		  (incf reuse-closed (nth 13 errt-sol))
		  (incf reuse (nth 14 errt-sol))
		  (incf current-search (nth 15 errt-sol))))
	      ;;		(incf (cdr (assoc :number-solved summary-errt)) solved)
	      (cond ((> solved 0)
		     (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~d, ~d, ~d, 0, 0, ~d" i algorithm prob-p prob-r solved
			     (/ cost solved 1.0) (/ time solved 1.0) (/ length solved 1.0) (/ nodes solved 1.0) (/ evaluations solved 1.0)
			     (/ reuse-closed solved 1.0) (/ reuse solved 1.0) (/ current-search solved 1.0)))
		    (t (format ostream "~%~d, ~d, ~a, ~a, 0, 0, 0, 0, 0, 0, 0, 0, 0" i algorithm prob-p prob-r))))))))))
;;  `((,sayphi-algorithm ,@summary-ehc) (,algorithm ,@summary-errt))
;; (summary-ehc (list (cons :solutions nil) (cons :number-solved 0) (cons :acc-cost 0) (cons :acc-length 0)
;; 			       (cons :acc-time 0) (cons :acc-nodes 0) (cons :acc-evaluations 0)))
;; 	    (summary-errt (list (cons :solutions nil) (cons :number-solved 0) (cons :acc-cost 0) (cons :acc-length 0) (cons :acc-time 0)
;; 				(cons :acc-nodes 0) (cons :acc-evaluations 0) (cons :reuse-closed 0) (cons :reuse 0) (cons :current-search 0)
;; 				(cons :acc-reuse-closed 0) (cons :acc-reuse 0) (cons :acc-current-search 0)))

;; 	       (push (list (cons :problem i) (cons :p 1.0) (cons :r 0.0) (cons :cost (nth 10 ehc-sol)) (cons :time (nth 6 ehc-sol)) (cons :length (nth 7 ehc-sol))
;; 			   (cons :nodes (nth 8 ehc-sol)) (cons :evaluations (nth 9 ehc-sol)))
;; 		     (cdr (assoc :solutions summary-ehc))))
;; 		 (push (list (cons :problem i) (cons :p 1.0) (cons :r 0.0) (cons :cost 0) (cons :time 0) (cons :length 0) (cons :nodes 0) (cons :evaluations 0))
;; 		       (cdr (assoc :solutions summary-ehc)))))
	      ;; 		 (incf (cdr (assoc :number-solved summary-ehc)))
	      ;; 		 (incf (cdr (assoc :acc-cost summary-ehc)) (nth 10 ehc-sol))
	      ;; 		 (incf (cdr (assoc :acc-time summary-ehc)) (nth 6 ehc-sol))
	      ;; 		 (incf (cdr (assoc :acc-nodes summary-ehc)) (nth 8 ehc-sol))
	      ;; 		 (incf (cdr (assoc :acc-evaluations summary-ehc)) (nth 9 ehc-sol)))
;; 		     (push (list (cons :problem i) (cons :p prob-p) (cons :r prob-r)
;; 				 (cons :reuse-closed (/ reuse-closed solved 1.0)) (cons :reuse (/ reuse solved 1.0)) (cons :current-search (/ current-search solved 1.0))
;; 				 (cons :cost (/ cost solved 1.0)) (cons :length (/ length solved 1.0))
;; 				 (cons :time (/ time solved 1.0)) (cons :nodes (/ nodes solved 1.0)) (cons :evaluations (/ evaluations solved 1.0)))
;; 			   (cdr (assoc :solutions summary-errt))))
;; 		       (push (list (cons :problem i) (cons :p prob-p) (cons :r prob-r)
;; 				   (cons :reuse-closed 0) (cons :reuse 0) (cons :current-search 0)
;; 				   (cons :cost 0) (cons :length 0)
;; 				   (cons :time 0) (cons :nodes 0) (cons :evaluations 0))
;; 			     (cdr (assoc :solutions summary-errt))))))))))))

;; (defun summary-results (ehc-solutions errt-solutions sayphi-algorithm algorithm number-repetitions avoided-computations problems-list)
;;   (do* ((summary-ehc (list (cons 'solutions nil) (cons 'number-solved 0) (cons 'acc-cost 0) (cons 'acc-time 0) (cons 'acc-nodes 0) (cons 'acc-evaluations 0)))
;; 	(summary-errt (list (cons 'solutions nil) (cons 'number-solved 0) (cons 'acc-cost 0) (cons 'acc-time 0) (cons 'acc-nodes 0) (cons 'acc-evaluations 0)
;; 			    (cons 'avoided-computations 0)))
;; 	(ehc-sols ehc-solutions (cdr ehc-sols))
;; 	(errt-sols errt-solutions)
;; 	(ehc-sol (car ehc-sols) (car ehc-sols))
;; 	(errt-sol nil)
;; 	(i 1 (1+ i))
;; 	(num-problems (length problems-list))
;; 	(solved 0 0) (nodes 0 0) (time 0 0) (cost 0 0) (evaluations 0))
;;       ((or (null ehc-sols)
;; 	   (null errt-sols))
;;        `((,sayphi-algorithm ,summary-ehc) (,algorithm ,summary-errt)))
;;     (cond ((solution-found ehc-sol)
;; 	   (push (list (cons 'problem (nth (- num-problems i) problems-list)) (cons 'solved t) (cons 'cost (solution-total-cost ehc-sol)) (cons 'time (solution-total-time ehc-sol))
;; 		       (cons 'nodes (solution-num-nodes ehc-sol)) (cons 'evaluations (solution-evaluated-nodes ehc-sol)))
;; 		 (cdr (assoc 'solutions summary-ehc)))
;; 	   (incf (cdr (assoc 'number-solved summary-ehc)))
;; 	   (incf (cdr (assoc 'acc-cost summary-ehc)) (solution-total-cost ehc-sol))
;; 	   (incf (cdr (assoc 'acc-time summary-ehc)) (solution-total-time ehc-sol))
;; 	   (incf (cdr (assoc 'acc-nodes summary-ehc)) (solution-num-nodes ehc-sol))
;; 	   (incf (cdr (assoc 'acc-evaluations summary-ehc)) (solution-evaluated-nodes ehc-sol)))
;; 	  (t (push (list (cons 'problem (nth (- num-problems i) problems-list)) (cons 'solved nil)) (cdr (assoc 'solutions summary-ehc)))))
;;     (dotimes (i number-repetitions)
;;       (setq errt-sol (pop errt-sols))
;;       (cond ((and errt-sol (solution-found errt-sol))
;; 	     (push (list (cons 'problem (nth (- num-problems i) problems-list)) (cons 'solved t) (cons 'cost (solution-total-cost errt-sol)) (cons 'time (solution-total-time errt-sol))
;; 			 (cons 'nodes (solution-num-nodes errt-sol)) (cons 'evaluations (solution-evaluated-nodes errt-sol)))
;; 		   (cdr (assoc 'solutions summary-errt)))
;; 	     (incf solved)
;; 	     (incf cost (solution-total-cost errt-sol))
;; 	     (incf time (solution-total-time errt-sol))
;; 	     (incf nodes (solution-num-nodes errt-sol))
;; 	     (incf evaluations (solution-evaluated-nodes errt-sol)))
;; 	    (t (push (list (cons 'problem (nth (- num-problems i) problems-list)) (cons 'solved nil)) (cdr (assoc 'solutions summary-errt))))))
;;     (incf (cdr (assoc 'number-solved summary-errt)) solved)
;;     (when (> solved 0)
;;       (setf (cdr (assoc 'avoided-computations summary-errt)) (/ avoided-computations solved 1.0))
;;       (incf (cdr (assoc 'acc-cost summary-errt)) (/ cost solved 1.0))
;;       (incf (cdr (assoc 'acc-time summary-errt)) (/ time solved 1.0))
;;       (incf (cdr (assoc 'acc-nodes summary-errt)) (/ nodes solved 1.0))
;;       (incf (cdr (assoc 'acc-evaluations summary-errt)) (/ evaluations solved 1.0)))))

;; search-options include :coverage and :length
;; anchors are the nodes from which there is a path to some tree
(defun cover-domain (init-node h-function cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let ((helpful (search-option-value :helpful search-options))
	(visited (make-hash-table))
	(nodes (list init-node))
	(anchors (make-hash-table))
	(coverage (search-option-value :coverage search-options))
	(length (search-option-value :length search-options))
	(node nil))
    (push node (gethash (snode-hash-code node) visited))
    (dotimes (i (/ coverage length))
      (setq node (choose-one nodes))
      (push node (gethash (snode-hash-code node) anchors))
      (if (not (snode-children node))
	  (expand-state node :helpful helpful))
      (dotimes (j length)
	(when node
	  (if (not (snode-children node))
	      (setq node (snode-parent node)))
	  (when node
	    (setq node (choose-one (snode-children node)))
	    (cond ((find node (gethash (snode-hash-code i-child) visited) :test #'equal-state)
		   (setq node (snode-parent node)))
		  (t (expand-state node :helpful helpful)
		     (push node nodes)
		     (push node (gethash (snode-hash-code node) visited))))))))
    anchors))

;; the list of anchors should be given as search-options
(defun coverage-based-search (init-node h-function cost-fn search-options &optional (problem *current-problem*))
  (declare (ignore cost-fn))
  (let ((helpful (search-option-value :helpful search-options))
	(lookahead (search-option-value :lookahead search-options))
	(anchors (search-option-value :anchors search-options))
	(visited (make-hash-table))
	(node init-node)
	(next-node nil))
    (find-path (find-path node (closest-node-from-anchors node anchors)) goals)))
