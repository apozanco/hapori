;; This file deals with printing and summarizing results
(in-package "COMMON-LISP-USER")

(defvar *print-reuse* nil)

;; results-file: name of file. It will find it in domains-dir/domain/result/
;; summary-solution-format can be either: :gnuplot or :csv
;; output-configurations is an alist ((p1 . r1) ... (pn . rn)) of the only ones I want in the output
;; time-bound allows to compute solvability under a given time bound, even if that was not the one used. Obviously, it must be under the real time bound used.
;; x-labels is a list of the form: ("20-0" "20-16" "30-0" "30-26" "40-0") where each label correspond to X labels starting from 1
;; planner is the planner to compare against (ehc, ff, a-star, ...)
;; planner-names is used to handle variable number of experiments
;; if print-tex-file-p is t (default), it will generate a tex file with a summary of results
;; results-fn: #'average or #'median
;; second-results: list of sublists, one per result file ((filename1 algorithm1) (filename2 algorithm2) ...) filename (string) in the same format as the .dat files generated by summary-results. For instance, (("lpg-adapt-output.dat" "LPG-Adapt"))
;; Example:
;; (summary-results "results-cups.lisp" :domain "test-grid" :p (list 0.0 0.3 0.7 1.0) :r (list 0.0 0.3 0.7 1.0) :number-repetitions 10 :number-modifications 1 :x-labels (list "0" "10" "20" "30" "40" "50"))

;; If experiments on unstability,
;; 1. Copy first lines of FF/EHC and change NIL for T
;; 2. Count-matches (without the new lines) of FF: X
;; 3. (summary-results "pfile20-60-stability.lisp" :domain "driverlog" :p (list 0.0 0.3 0.7 1.0) :r (list 0.0 0.3 0.7 1.0) :number-repetitions 5 :number-modifications X :accumulated-p nil)
(defun summary-results (results-file &key (domain "driverlog")  (p (list 0.0 0.3 0.7 1.0)) (r (list 0.0 0.3 0.7 1.0)) (number-repetitions 5) (number-modifications 5)
			(plot-file (concatenate 'string *domains-dir* domain "/result/plot.plt"))
			(summary-solution-format :gnuplot)
			(output-file (concatenate 'string *domains-dir* domain "/result/errt-results."
						  (if (eq summary-solution-format :gnuplot) "dat" (if (eq *say-solution-format* :list) "lisp" "csv"))))
			(planner 'ff) (planner-names (list 'ehc 'ff))
			(output-configurations 'all) (accumulated-p t) (time-bound most-positive-fixnum) (plot-planner-p t) (dont-plot-zeros-p nil)
			(print-tex-file-p t) (x-labels nil) (results-fn #'median) (second-results nil))
  (let ((the-results nil)
	(gnuplot-p (or (eq summary-solution-format :gnuplot) (eq *say-solution-format* :list)))
	(i 0)
	(configurations (list (list (cons 1.0 0.0) (cons 'cost 0) (cons 'solved 0) (cons 'nodes 0) (cons 'time 0) (cons 'length 0)))))
    (with-open-file (istream (concatenate 'string *domains-dir* domain "/result/" results-file) :direction :input)
      (setq the-results (read istream)))
    ;;     (format t "~%Length the results: ~d, Algorithm: ~a" (length the-results) (nth 2 (car the-results)))
    (with-open-file (ostream output-file :direction :output :if-exists :supersede :if-does-not-exist :create)
      (if gnuplot-p
	  (format ostream
		  "# 0 Prob, 1 Solved, 2 Time, 3 Length, 4 Nodes, 5 Evals, 6 Cost, 7 ReuseClosed, 8 Reuse, 9 CurrentSearch, 10 NumberBetterLength, 11 NumberBetterCost, 12 TotalTimeHeuristic, 13 Unstability (12 AvgTimeHeuristic 13 TotalTimeHeuristic 14 Unstability in planner) 15 Solved-conf1, 16 Time-conf1, ...")
	  (format ostream
		  ";;  Prob, Solved, Time, Length, Nodes, Evals, Cost, ReuseClosed, Reuse, CurrentSearch, NumberBetterLength, NumberBetterCost, TotalTimeHeuristic"))
      (do* ((solved 0) (nodes 0) (time 0) (cost 0) (length 0) (evaluations 0) (reuse-closed 0) (reuse 0) (current-search 0) (number-better-length 0) (number-better-cost 0) (unstability 0)
	    (time-heuristic 0)
	    (results t)
	    ;; 	    (results (cdr the-results) (if (zerop (mod i number-modifications)) (cdr results) results))
	    (aux-results nil)
	    (line "" "")
	    (planner-sol nil) (errt-sol nil)
	    (algorithm nil)
	    (unsolved-by-one nil nil)
	    (first nil)
	    (locally-all-unsolved-p nil)
	    (repetitions 0))
	   ((null results))
	(incf i)
	(if (= 1 i) (setq results the-results))
	;; This is where the solution comes from for each modification and we have to see which is the first solved instance of the problem
	(when (or (and (= number-modifications 1) (= i 1))
		  (= 1 (mod i number-modifications)))
	  (setq results (planner-results planner results))
	  (do ((problem (nth 1 (car results)))
	       (initp t nil)
	       (solvedp (nth 5 (car results)) (nth 5 (car results))))
	      ((or solvedp (null results))
	       (setq results (if results
				 (if initp
				     (planner-results planner (cdr results))
				     (member problem (cdr results) :key #'cadr)))))
	    (setq results (planner-results planner results)))) ;; (cdr results))))
	(setq aux-results results)
 	(if *trace-errt-p* (format t "~%Length results: ~d, Algorithm: ~a" (length results) (nth 2 (car results))))
	(when results
	  ;; I see if all configurations solved the problem
	  (when accumulated-p
	    (setq aux-results (planner-results planner aux-results))
	    (setq first (pop aux-results))
	    (setq unsolved-by-one (and plot-planner-p (or (not (nth 5 first)) (> (nth 6 first) time-bound))))
	    ;;  	  (format t "~%Unsolved PLANNER: ~a" unsolved-by-one)
	    (if (not unsolved-by-one)
		(dolist (prob-p (if (listp p) p (list p)))
		  (if (not unsolved-by-one)
		      (dolist (prob-r (if (listp r) r (list r)))
			(when (and (not unsolved-by-one)
				   (<= (+ prob-p prob-r) 1.0)
				   (not (and (= prob-p 1.0) (= prob-r 0.0))))
			  (setq locally-all-unsolved-p t)
			  (dotimes (j (if (and (= prob-p 0.0) (= prob-r 1.0)) 1 number-repetitions))
			    (setq first (pop aux-results))
			    (if (or (eq output-configurations 'all)
				    (member (cons prob-p prob-r) output-configurations :test #'equal))
				(setq locally-all-unsolved-p (and locally-all-unsolved-p (or (not (nth 5 first)) (> (nth 6 first) time-bound))))
				;; 			    (format t "~%Unsolved (~a,~a) repetition ~d: ~a" prob-p prob-r j locally-all-unsolved-p)
				))
			  (if (or (eq output-configurations 'all)
				  (member (cons prob-p prob-r) output-configurations :test #'equal))
			      (setq unsolved-by-one (or unsolved-by-one locally-all-unsolved-p)))))))))
	  (setq results (planner-results planner results))
	  (setq planner-sol (pop results))
	  ;; 	  (setq sayphi-algorithm (or sayphi-algorithm (nth 2 planner-sol)))
	  (if *trace-errt-p*
	      (format t "~%Prob: ~a, Order: ~d, Unsolved: ~a, algorithm: ~a, mod: ~d" (nth 1 planner-sol) i unsolved-by-one (nth 2 planner-sol) (mod i number-modifications)))
	  (if (or (not accumulated-p) (not unsolved-by-one))
	      (cond ((not plot-planner-p) (format ostream "~%~d" i))
		    (accumulated-p
		     (format ostream (if gnuplot-p "~%~d ~d ~4$ ~d ~d ~d ~4$ 0 0 ~d 0 0 ~4$ ~4$ ~d" "~%~d, ~d, ~4$, ~d, ~d, ~d, ~4$, 0, 0, ~d, 0, 0, ~4$, ~4$, ~d")
			     i
			     (if (and (nth 5 planner-sol) (<= (nth 6 planner-sol) time-bound))
				 (incf (cdr (assoc 'solved (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))))
				 (cdr (assoc 'solved (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))))
			     (incf (cdr (assoc 'time (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 6 planner-sol))
			     (incf (cdr (assoc 'length (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 7 planner-sol))
			     (incf (cdr (assoc 'nodes (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 8 planner-sol))
			     (nth 9 planner-sol)
			     (incf (cdr (assoc 'cost (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 10 planner-sol))
			     (nth 7 planner-sol) (nth 17 planner-sol) (nth 18 planner-sol) (nth 20 planner-sol)))
		    ((and (nth 5 planner-sol) (<= (nth 6 planner-sol) time-bound))
		     (format ostream (if gnuplot-p "~%~d 1 ~4$ ~d ~d ~d ~4$ 0 0 ~d 0 0 ~4$ ~4$ ~d" "~%~d, 1, ~4$, ~d, ~d, ~d, ~4$, 0, 0, ~d, 0, 0, ~4$, ~4$, ~d$")
			     i (nth 6 planner-sol) (nth 7 planner-sol) (nth 8 planner-sol) (nth 9 planner-sol) (nth 10 planner-sol) (nth 7 planner-sol)
			     (nth 17 planner-sol) (nth 18 planner-sol) (nth 20 planner-sol)))
		    (t (format ostream (if gnuplot-p "~%~d 0 0.0 0 0 0 0.0 0 0 0 0 0 0.0 ~4$ 0" "~%~d, 0, 0.0, 0, 0, 0, 0.0, 0, 0, 0, 0, 0, 0.0, ~4$, 0") i (nth 18 planner-sol)))))
	  (dolist (prob-p (if (listp p) p (list p)))
	    (dolist (prob-r (if (listp r) r (list r)))
	      (when (and (<= (+ prob-p prob-r) 1.0)
			 (not (and (= prob-p 1.0) (= prob-r 0.0))))
		(setq repetitions (if (and (= prob-p 0.0) (= prob-r 1.0)) 1 number-repetitions))
		(cond ((and (or (not accumulated-p) (not unsolved-by-one))
			    (or (eq output-configurations 'all)
				(member (cons prob-p prob-r) output-configurations :test #'equal)))
		       (setq solved 0 nodes nil time nil cost nil length nil evaluations nil reuse-closed nil reuse nil current-search nil number-better-length 0 number-better-cost 0
			     time-heuristic nil unstability nil)
		       (if (= i 1) ;; so that we know how many ERRT-PLAN configurations we have and which ones and also keep accumulated data
			   (push `((,prob-p . ,prob-r) (cost . 0) (solved . 0) (nodes . 0) (time . 0) (length . 0)) configurations))
		       (dotimes (j repetitions)
			 (setq errt-sol (pop results))
			 (setq algorithm (or algorithm (nth 2 errt-sol)))
			 ;; 			 (format t "~%Algorithm: ~a" (nth 2 errt-sol))
			 (when (and (nth 5 errt-sol) (<= (nth 6 errt-sol) time-bound))
			   (incf solved)
			   (push (nth 6 errt-sol) time)
			   (if (< (nth 7 errt-sol) (nth 7 planner-sol)) (incf number-better-length))
			   (push (nth 7 errt-sol) length)
			   (push (nth 8 errt-sol) nodes)
			   (push (nth 9 errt-sol) evaluations)
			   (if (< (nth 10 errt-sol) (nth 10 planner-sol)) (incf number-better-cost))
			   (push (nth 10 errt-sol) cost)
			   (push (nth 13 errt-sol) reuse-closed)
			   (push (nth 14 errt-sol) reuse)
			   (push (nth 15 errt-sol) current-search)
			   (push (nth 18 errt-sol) time-heuristic)
			   (if (nth 20 errt-sol) ;; for previous executions
			       (push (nth 20 errt-sol) unstability))))
		       ;;		(incf (cdr (assoc :number-solved summary-errt)) solved)
		       (cond (accumulated-p
			      ;; 			      (format t "~%Before accumulating")
			      ;; 			      (format t "~%Configurations: ~a" configurations)
			      (if gnuplot-p
				  (if (> solved 0)
				      (format ostream " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d"
					      (incf (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ solved repetitions 1.0))
					      (incf (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn time solved))
					      (incf (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn length solved))
					      (incf (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn nodes solved))
					      (funcall results-fn evaluations solved)
					      (incf (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn cost solved))
					      (funcall results-fn reuse-closed solved) (funcall results-fn reuse solved) (funcall results-fn current-search solved)
					      number-better-length number-better-cost
					      (funcall results-fn time-heuristic solved) (funcall results-fn unstability solved))
				      (format ostream " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d"
					      (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      0
					      (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      0 0 0 0 0 0 0))
				  (if (> solved 0)
				      (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~2$, ~2$, ~2$, ~2$, ~2$, ~2$, ~d, ~d, ~4$, ~d"
					      i algorithm prob-p prob-r
					      (incf (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ solved repetitions 1.0))
					      (incf (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn cost solved))
					      (incf (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn time solved))
					      (incf (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn length solved))
					      (incf (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn nodes solved))
					      (funcall results-fn evaluations solved) (funcall results-fn reuse-closed solved)
					      (funcall results-fn reuse solved) (funcall results-fn current-search solved)
					      number-better-length number-better-cost (funcall results-fn time-heuristic solved) (funcall results-fn unstability solved))
				      (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~2$, ~2$, ~2$, ~2$, ~2$, ~2$, ~d, ~d, ~4$, ~d"
					      i algorithm prob-p prob-r
					      (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
					      0 0 0 0 0 0 0 0)))
			      ;;  			      (format t "~%After accumulating")
			      ;;  			      (format t "~%Configurations: ~a" configurations)
			      )
			     ((> solved 0)
			      (if gnuplot-p
				  (format ostream " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d"
					  solved (funcall results-fn time solved) (funcall results-fn length solved) (funcall results-fn nodes solved)
					  (funcall results-fn evaluations solved)  (funcall results-fn cost solved)
					  (funcall results-fn reuse-closed solved) (funcall results-fn reuse solved) (funcall results-fn current-search solved)
					  number-better-length number-better-cost (funcall results-fn time-heuristic solved)
					  (funcall results-fn unstability solved))
				  (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~2$, ~2$, ~2$, ~2$, ~2$, ~2$, ~d, ~d, ~4$, ~d"
					  i algorithm prob-p prob-r solved
					  (funcall results-fn cost solved) (funcall results-fn time solved) (funcall results-fn length solved)
					  (funcall results-fn nodes solved) (funcall results-fn evaluations solved)
					  (funcall results-fn reuse-closed solved) (funcall results-fn reuse solved) (funcall results-fn current-search solved)
					  number-better-length number-better-cost (funcall results-fn time-heuristic solved)
					  (funcall results-fn unstability solved))))
			     (t (if gnuplot-p
				    (format ostream  " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d" 0 0.0 0.0 0.0 0.0 0.0 0 0 0 number-better-length number-better-cost 0.0 0)
				    (format ostream "~%~d, ~d, ~a, ~a, 0, 0, 0, 0, 0, 0, 0, 0, 0, ~d, ~d, 0, 0" i algorithm prob-p prob-r number-better-length number-better-cost)))))
		      (t (dotimes (j repetitions)
			   ;; 			   (format t "~%Algorithm: ~a, (~a,~a), (~a,~a)" (nth 2 (car results)) prob-p prob-r (nth 3 (car results)) (nth 4 (car results)))
			   (pop results)))))))
	  (if gnuplot-p
	      (format ostream  " ~a" (if unsolved-by-one 0 1))
	      (format ostream  ", ~a" (if unsolved-by-one 0 1))))))
    (if print-tex-file-p (generate-tex-file domain configurations i))
    (when gnuplot-p
      (generate-plot-file domain (cdr (reverse (mapcar #'car configurations))) output-file plot-file planner plot-planner-p (or accumulated-p dont-plot-zeros-p) x-labels second-results)
#+Darwin      (execute-shell-command (format nil "cd; cd ~a~(~a~)/result/; /opt/local/bin/gnuplot plot.plt" *domains-dir* domain))
#-Darwin      (execute-shell-command (format nil "cd; cd ~a~(~a~)/result/; /usr/bin/gnuplot plot.plt" *domains-dir* domain))
			     )))
;;				      (and dont-plot-zeros-p (not accumulated-p)) x-labels))))

(defun init-results-files (out-file result-file probs-prefix search-options)
;;  (ensure-directories-exist (concatenate 'string *domain-dir* "result/"))
  (multiple-value-bind (sec min hour day month year) (get-decoded-time)
    (setq result-file (if (stringp out-file)
			  (format nil "~a" *results-pathname* out-file)
			  (format nil "~a~a-~d-~d-~d-~d-~d.~a" *results-pathname* probs-prefix (search-option-value :timeout search-options) hour min day month
				  (if (eq *say-solution-format* :list) "lisp" "csv")))))
  (with-open-file (out-stream result-file :direction :output :if-exists :supersede :if-does-not-exist :create)
    (when (eq *say-solution-format* :list)
      (format out-stream ";; Search options:")
      (dolist (option search-options)
	(format out-stream "~%;;   ~a" option)))
    (format out-stream "~%;;  Lisp: ")
    #+SBCL (format out-stream "SBCL")
    #+CLISP (format out-stream "CLISP")
    #+ALLEGRO (format out-stream "ALLEGRO")
    (format out-stream (if (find-argument search-options :p)
			   (case *say-solution-format*
			     (:list "~%;; 0 Prob, 1 NameProb, 2 Algorithm,3 P, 4 R, 5 Found,6 Time,7 Length,8 Nodes,9 Evaluations,10 Cost,11 Reason,12 Avoided,13 Reuse-closed,14 Reuse,15 Current-search, 16 TimeGoalReg, 17 AvgTimeHeuristic, 18 TotalTimeHeuristic, 19 Time-simpler-problem, 20 Unstability~%(")
			     (:values "~%;; 0 Prob, 1 NameProb, 2 Algorithm,3 P, 4 R, 5 Found,6 Time,7 Length,8 Nodes,9 Evaluations,10 Cost,11 Reason,12 Avoided,13 Reuse-closed,14 Reuse,15 Current-search, 16 TimeGoalReg, 17 AvgTimeHeuristic, 18 TotalTimeHeuristic, 19 Time-simpler-problem, 20 Unstability~%(")
			     (t "~%("))
			   "~%;; 0 Prob, 1 NameProb, 2 Found, 3 Time, 4 Length, 5 Nodes, 6 Evaluations, 7 Cost, 8 Reason~%(")))
  result-file)

(defun print-result-file (save-result result-file count-prob new-prob algorithm this-sol computation-avoided &optional (p 1.0) (r 0.0) (time-goal-regression 0) (time-simpler-problem 0)
				      (previous-actions nil))
  (declare (special *print-reuse*))
  (if save-result
      (let ((number-reuse-closed 0)
	    (number-reuse 0)
	    (number-current-search 0)
	    (unstability (length previous-actions))
	    (previous nil)
	    (new-actions nil)
	    (errt-p (or (eq algorithm 'errt-plan) (eq algorithm 'errt-hc)))
	    (plist (problem-plist *current-problem*)))
	(with-open-file (out-stream result-file :direction :output :if-exists :append :if-does-not-exist :create)
	  (format out-stream (case *say-solution-format*
			       (:values "~d, ~a, ~a, ~a, ~a")
			       (:list " (~d ~a ~a ~a ~a")
			       (:tags-values "NumProb: ~d Prob: ~a Algorithm: ~a P: ~a R: ~a "))
		  count-prob (pathname-name new-prob) algorithm p r)
	  (dolist (node (solution-path this-sol))
	    (if previous-actions
		(push (gaction-planaction (snode-applied-action node)) new-actions))
	    (case (getf (snode-plist node) :expansion-reason)
	      (:reuse-closed (incf number-reuse-closed) (if (and *print-reuse* errt-p) (format out-stream "RC,")))
	      (:reuse (incf number-reuse) (if (and *print-reuse* errt-p) (format out-stream "R,")))
	      (:current-search (incf number-current-search) (if (and *print-reuse* errt-p) (format out-stream "C,")))
	      (t (if errt-p (format t "~%Something happened"))
		 (if (and *print-reuse* errt-p) (format out-stream "C,"))
		 (incf number-current-search))))
	  ;; only for tracing
	  (when (and *print-reuse* (eq algorithm 'errt-plan) (solution-found this-sol) (numberp (solution-length this-sol)) (> (solution-length this-sol) 0) previous-actions)
	    (format t "~2%Previous plan: ")
	    (dolist (a previous-actions)
	      (format t "~%  ~a" a))
	    (format t "~2%New plan: ")
	    (dolist (a new-actions)
	      (format t "~%  ~a" a))
	    (format t "~2%Differences: ~a" (set-difference new-actions previous-actions :test #'equal))
	    (format t "~%Number of Differences: ~d, ~d"
		    (length (set-difference new-actions previous-actions :test #'equal))
		    (length (set-difference previous-actions new-actions :test #'equal))))
	  ;; according to the LPG-adapt paper (ICAPS'06)
	  (if (and (eq algorithm 'errt-plan) (solution-found this-sol) (numberp (solution-length this-sol)) (> (solution-length this-sol) 0) previous-actions)
	      (setq unstability (plan-unstability new-actions previous-actions)))
	  (format out-stream (case *say-solution-format*
			       (:values ", ~a, ~a, ~a, ~a, ~a, ~4$, ~4$, ~4$, ~4$, ~d~%")
			       (:list " ~a ~a ~a ~a ~a ~4$ ~4$ ~4$ ~4$ ~d)~%")
			       (:tags-values "Solution:~a Avoided: ~a Reuse-closed: ~a Reuse: ~a Current-search: ~a Time goal regression: ~4$ Avg. time heuristic comp: ~4$ Time Heuristic Comp: ~4$ Time-simpler-problem: ~4$ Unstability: ~d~%"))
		  (format-solution this-sol time-goal-regression) computation-avoided number-reuse-closed number-reuse number-current-search time-goal-regression
		  (if (> (getf plist :node-evaluated) 0)
		      (/ (getf plist :heuristic-time)
			 (getf plist :node-evaluated)))
		  (getf plist :heuristic-time)
		  time-simpler-problem unstability)))))
;; 	  (format t "~%Unstability before: ~d" unstability)
;; 	  (if previous-actions
;; 	      (setq unstability (/ unstability (length previous-actions) 1.0)))
;; 	  (format t "~%Unstability after: ~d" unstability)

(defun plan-unstability (new-plan old-plan)
  (+ (length (set-difference new-plan old-plan :test #'equal))
     (length (set-difference old-plan new-plan :test #'equal))))

(defun format-solution (solution &optional (time-goal-regression 0))
  (format nil (case *say-solution-format*
		(:values "~t~a, ~t~4$, ~t~a, ~t~a, ~t~a, ~t~a, ~t~a")
		(:list " ~a ~4$ ~a ~a ~a ~a ~a")
		(:tags-values " Found:~a Time:~a Nodes:~a Evaluated:~d Cost:~a Reason:~a"))
	  (solution-found solution) (+ (solution-total-time solution) time-goal-regression)
	  (solution-length solution) (solution-num-nodes solution) (solution-evaluated-nodes solution)
	  (solution-total-cost solution) (solution-stop-reason solution)))

(defun solution-print (solution stream z)
  (declare (type solution solution)
	   (ignore z))
  (format stream "~%#<SOLUTION: ~a  " (solution-found solution))
  (format stream "~%       Length     : ~d " (solution-length solution))
  (format stream "~%       Nodes      : ~d " (solution-num-nodes solution))
  (format stream "~%       Evaluated  : ~d" (solution-evaluated-nodes solution))
  (format stream "~%       Total time : ~d" (solution-total-time solution))
;;  (format stream "~%       Instantiating Time: ~d" (solution-pre-time solution))
;;  (format stream "~%       Search Time       : ~d" (solution-search-time solution))
;;  (format stream "~%       Metric            : ~a" (problem-metric *current-problem*))
;;  (format stream "~%       Depth            : ~a" (solution-depth solution))
  (format stream "~%       Total cost : ~a >" (solution-total-cost solution))
  )

;; This re-implements the standard one for the competition (ipc-p=t)
(defun say-pp-solution (solution &optional (evaltrace nil) (stream t) (ipc-p nil))
  (let ((*print-pretty* nil) (planaction-counter 0) (out-trace "") (solution-list-p (listp solution)) (parallel-plan-p nil))
    (cond ((or ipc-p (> *say-output* 0))
	   (setq parallel-plan-p (and solution-list-p (numberp (caar solution))))
	   (if ipc-p
	       (if solution-list-p
		   (if parallel-plan-p
		       (format stream ";; Length: ~d~%;; Makespan: ~d~2%" (length solution) (+ 1 (caar (last solution))))
		       (format stream ";; Length: ~d~2%" (length solution)))
		   (format stream ";; Length: ~d~%;; Cost: ~d~%;; Time: ~,3f~%;; Nodes: ~d~2%"
			   (solution-length solution) (solution-total-cost solution) (solution-total-time solution) (solution-num-nodes solution)))
	       (if (or (and (not solution-list-p) (solution-found solution))
		       solution)
		   (format stream "~% Solution: ")
		   (format stream "~% Path When Stopped: ")))
	   (dolist (i-node (if solution-list-p solution (solution-path solution)) solution)
	     (if (and (not solution-list-p) evaltrace)
		 (setf out-trace (format nil "{g:~2$ , h:~2$ , f:~2$}" (snode-g-value i-node) (snode-h-value i-node) (snode-f-value i-node)))
		 (setf out-trace ""))
	     (cond ((or solution-list-p (listp i-node))
		    (if parallel-plan-p
			(format stream "~d: ~a [1]~%" (car i-node) (cadr i-node))
			(format stream "~d: ~a [1]~%" planaction-counter i-node)))
		   ((lhnode-p i-node)
		    (dolist (i-lhaction (lhnode-lookahead-plan i-node))
		      (format stream "     ~d: ~a~%" planaction-counter (gaction-planaction i-lhaction))))
		   (t
		    (format stream "~d: ~a [~a]  ~a~%" planaction-counter (snode-plan-action i-node) (snode-cost i-node) out-trace)))
	     (incf planaction-counter)))
	  (t (pp-list (if (or solution-list-p (not (solution-p solution)))
			  solution
			  (mapcar #'(lambda (snode) (snode-plan-action snode))
				  (solution-path solution)))
		      1 stream t nil nil)))))



(defun generate-tex-file (domain configurations number-problems)
  (with-open-file (ostream (concatenate 'string *domains-dir* domain "/result/errt-results.tex")
			   :direction :output :if-exists :supersede :if-does-not-exist :create)
    (format ostream "\\documentclass[landscape]{article}
\\begin{document}")
    (format ostream "~2%Results in domain ~:(~a~) with problems: ~d" domain number-problems)
    (format ostream "~2%Configurations:\\\\")
    (dotimes (i (length configurations))
      (format ostream "~%~a: $p=~1$, r_a=~1$, r_g$=~1$\\\\" (if (= 1.0 (caar (nth i configurations))) "FF" i)
	      (caar (nth i configurations)) (cdar (nth i configurations)) (- 1 (caar (nth i configurations)) (cdar (nth i configurations)))))
    (format ostream "~2%")
    (format ostream "\\hspace*{-4cm}
\\begin{tabular}{l")
    (dotimes (i (length configurations))
      (format ostream "l"))
    (format ostream "}
Metric")
    (dotimes (i (length configurations))
      (format ostream " & ~a" (if (= 1.0 (caar (nth i configurations))) "FF" i)))
    ;;     (dolist (conf configurations)
    ;;       (format ostream "& \\multicolumn{1}{c}{\\bf $p=~1$, r_a=~1$, r_g=~1$$}" (caar conf) (cdar conf) (- 1 (caar conf) (cdar conf))))
    (format ostream "\\\\
Solved")
    (dolist (conf configurations)
      (format ostream " & ~1$" (cdr (assoc 'solved (cdr conf)))))
    (format ostream "\\\\
Time")
    (dolist (conf configurations)
      (format ostream " & ~3$" (cdr (assoc 'time (cdr conf)))))
    (format ostream "\\\\
Length")
    (dolist (conf configurations)
      (format ostream " & ~1$" (cdr (assoc 'length (cdr conf)))))
    (format ostream "\\\\
Nodes")
    (dolist (conf configurations)
      (format ostream " & ~1$" (cdr (assoc 'nodes (cdr conf)))))
    (format ostream "~%\\end{tabular}~%\\end{document}~%")))

;; In case dont-plot-zeros-p=T, it will not print the positions not solved by all
(defun generate-plot-file (domain configurations results-file plot-file sayphi-algorithm plot-planner-p dont-plot-zeros-p x-labels second-results)
  (let ((end-column (+ (if plot-planner-p 15 1) 1 (* (length configurations) 13))))
    (setq second-results (mapcar #'(lambda (filename-algorithm)
				     (cons (concatenate 'string *domains-dir* domain "/result/" (car filename-algorithm))
					   (cdr filename-algorithm)))
				 second-results))
    (with-open-file (ostream plot-file :direction :output :if-exists :supersede :if-does-not-exist :create)
      (format ostream "set autoscale
set style data lines
set key inside left
set terminal png enhanced font \"Vera,12\"
set xlabel 'Problems'
set yrange [0:]
# set xrange [60:85]
# set xlabel 'Size of L task'")
      (cond (x-labels
	     (format ostream "~%set xtics (")
	     (do ((the-labels x-labels (cdr the-labels))
		  (i 0 (1+ i)))
		 ((null the-labels))
	       (format ostream "~s ~d~a" (car the-labels) i (if (cdr the-labels) "," "")))
	     (format ostream ")~%"))
	    (t (format ostream "~%# set xtics (\"20-0\" 1, \"20-16\" 2, \"30-0\" 3, \"30-26\" 4, \"40-0\" 5, \"40-36\" 6, \"50-0\" 7, \"50-46\" 8, \"60-0\" 9, \"60-56\" 10)")))
      (format ostream "
set output 'results-~(~a~)-num-ops.png'
set key tmargin
set terminal png enhanced font \"Vera,8\"
set ylabel 'Length of solution'
plot" domain)
      (if plot-planner-p
	  (format ostream " ~s using 1:($~d == 1 ? $4 : NaN) title '~a' with linespoints," results-file (if dont-plot-zeros-p end-column 2) sayphi-algorithm))
      (do* ((confs configurations (cdr confs))
	    (conf (car confs) (car confs))
	    (i 0 (1+ i)))
	   ((null confs))
	(format ostream " ~s using 1:(~a ? $~d : NaN) title 'ERRT-Plan p=~1$ ra=~1$ rg=~1$' with linespoints" results-file
		(if dont-plot-zeros-p
		    (format nil "$~d == 1" end-column)
		    (format nil "$~d > 0" (plot-column i 1 plot-planner-p)))
		(plot-column i 3 plot-planner-p)
		(car conf) (cdr conf) (- 1 (+ (car conf) (cdr conf))))
	(if (cdr confs)
	    (format ostream ",")))
      (dolist (algorithm second-results)
	(format ostream ", ~s using 1:($2 == 1 ? $4 : NaN) title '~a' with linespoints" (car algorithm) (cadr algorithm)))
      (format ostream "

# set logscale y

set output 'results-~(~a~)-time.png'
set key tmargin
set terminal png enhanced font \"Vera,8\"
set ylabel 'Time'
plot" domain)
      (if plot-planner-p
	  (format ostream " ~s using 1:($~d == 1 ? $3 : NaN) title '~a' with linespoints," results-file (if dont-plot-zeros-p end-column 2) sayphi-algorithm))
      (do* ((confs configurations (cdr confs))
	    (conf (car confs) (car confs))
	    (i 0 (1+ i)))
	   ((null confs))
	(format ostream " ~s using 1:(~a ? $~d : NaN) title 'ERRT-Plan p=~1$ ra=~1$ rg=~1$' with linespoints" results-file
		(if dont-plot-zeros-p
		    (format nil "$~d == 1" end-column)
		    (format nil "$~d > 0" (plot-column i 1 plot-planner-p)))
		(plot-column i 2 plot-planner-p)
		(car conf) (cdr conf) (- 1 (+ (car conf) (cdr conf))))
	(if (cdr confs)
	    (format ostream ",")))
      (dolist (algorithm second-results)
	(format ostream ", ~s using 1:($2 == 1 ? $3 : NaN) title '~a' with linespoints" (car algorithm) (cadr algorithm)))
      (format ostream "

# set unlogscale y

set output 'results-~(~a~)-solved.png'
set key tmargin
set terminal png enhanced font \"Vera,8\"
set ylabel 'Number of solved problems'
plot" domain)
      (if plot-planner-p
	  (format ostream " ~s using 1:2 title '~a' with linespoints," results-file sayphi-algorithm))
      ;; ($~d == 1 ? $2 : NaN) end-column sayphi-algorithm
      (do* ((confs configurations (cdr confs))
	    (conf (car confs) (car confs))
	    (i 0 (1+ i)))
	   ((null confs))
	(format ostream " ~s using 1:~d title 'ERRT-Plan p=~1$ ra=~1$ rg=~1$' with linespoints" results-file (plot-column i 1 plot-planner-p)
		(car conf) (cdr conf) (- 1 (+ (car conf) (cdr conf))))
	(if (cdr confs)
	    (format ostream ",")))
      ;; 	(format ostream ", ~s using 1:($~d == 1 ? $~d : NaN) title 'ERRT-Plan p=~1$ ra=~1$ rg=~1$' with linespoints" results-file end-column (+ 1  (+ 15 (* i 13)))
      ;;      (car conf) (cdr conf) (- 1 (+ (car conf) (cdr conf)))))      
      (dolist (algorithm second-results)
	(format ostream ", ~s using 1:($2 == 1 ? $2 : NaN) title '~a' with linespoints" (car algorithm) (cadr algorithm)))
      (format ostream "

set output 'results-~(~a~)-better-length.png'
set key tmargin
set terminal png enhanced font \"Vera,8\"
set ylabel 'Number of problems in which better than ~a'
plot" domain sayphi-algorithm)
      ;; plot ~s using f(3) title '~a' with linespoints" results-file end-column sayphi-algorithm)
      (do* ((confs configurations (cdr confs))
	    (conf (car confs) (car confs))
	    (i 0 (1+ i)))
	   ((null confs))
	(format ostream " ~s using 1:($~d == 1 ? $~d : NaN) title 'ERRT-Plan p=~1$ ra=~1$ rg=~1$' with linespoints" results-file end-column (plot-column i 10 plot-planner-p)
		(car conf) (cdr conf) (- 1 (+ (car conf) (cdr conf))))
	(if (cdr confs) (format ostream ",")))
      (format ostream "
      
set output 'results-~(~a~)-cost.png'
set key tmargin
set terminal png enhanced font \"Vera,8\"
set ylabel 'Cost'
plot" domain)
      (if plot-planner-p
	  (format ostream " ~s using 1:($~d == 1 ? $7 : NaN) title '~a' with linespoints," results-file end-column sayphi-algorithm))
      (do* ((confs configurations (cdr confs))
      	    (conf (car confs) (car confs))
      	    (i 0 (1+ i)))
      	   ((null confs))
      	(format ostream " ~s using 1:($~d == 1 ? $~d : NaN) title 'ERRT-Plan p=~1$ ra=~1$ rg=~1$' with linespoints" results-file end-column (plot-column i 6 plot-planner-p)
		(car conf) (cdr conf) (- 1 (+ (car conf) (cdr conf))))
	(if (cdr confs)
	    (format ostream ",")))
      (dolist (algorithm second-results)
	(format ostream ", ~s using 1:($2 == 1 ? $7 : NaN) title '~a' with linespoints" (car algorithm) (cadr algorithm)))
      (format ostream "

set output 'results-~(~a~)-time-heuristic.png'
set key tmargin
set terminal png enhanced font \"Vera,8\"
set ylabel 'Heuristic Computation Time'
plot" domain)
      (if plot-planner-p
	  (format ostream " ~s using 1:($~d == 1 ? $14 : NaN) title '~a' with linespoints," results-file end-column sayphi-algorithm))
      (do* ((confs configurations (cdr confs))
	    (conf (car confs) (car confs))
	    (i 0 (1+ i)))
	   ((null confs))
	(format ostream " ~s using 1:($~d == 1 ? $~d : NaN) title 'ERRT-Plan p=~1$ ra=~1$ rg=~1$' with linespoints" results-file end-column (plot-column i 12 plot-planner-p)
		(car conf) (cdr conf) (- 1 (+ (car conf) (cdr conf))))
	(if (cdr confs)
	    (format ostream ",")))
      (format ostream "

set output 'results-~(~a~)-unstability.png'
# set yrange [0:1]
set key tmargin
set terminal png enhanced font \"Vera,8\"
set ylabel 'Unstability of solutions'
plot" domain)
      (if plot-planner-p
	  (format ostream " ~s using 1:($~d == 1 ? $14 : NaN) title '~a' with linespoints," results-file end-column sayphi-algorithm))
      (do* ((confs configurations (cdr confs))
	    (conf (car confs) (car confs))
	    (i 0 (1+ i)))
	   ((null confs))
	(format ostream " ~s using 1:($~d == 1 ? $~d : NaN) title 'ERRT-Plan p=~1$ ra=~1$ rg=~1$' with linespoints" results-file end-column (plot-column i 13 plot-planner-p)
		(car conf) (cdr conf) (- 1 (+ (car conf) (cdr conf))))
	(if (cdr confs)
	    (format ostream ",")))
      (dolist (algorithm second-results)
	(format ostream ", ~s using 1:($2 == 1 ? $14 : NaN) title '~a' with linespoints" (car algorithm) (cadr algorithm))))))

(defun plot-column (i column plot-planner-p)
   (+ column (if plot-planner-p 15 1) (* i 13)))

(defun planner-results (planner results)
  (member planner results :key #'caddr))


;;  `((,sayphi-algorithm ,@summary-ehc) (,algorithm ,@summary-errt))
;; (summary-ehc (list (cons :solutions nil) (cons :number-solved 0) (cons :acc-cost 0) (cons :acc-length 0)
;; 			       (cons :acc-time 0) (cons :acc-nodes 0) (cons :acc-evaluations 0)))
;; 	    (summary-errt (list (cons :solutions nil) (cons :number-solved 0) (cons :acc-cost 0) (cons :acc-length 0) (cons :acc-time 0)
;; 				(cons :acc-nodes 0) (cons :acc-evaluations 0) (cons :reuse-closed 0) (cons :reuse 0) (cons :current-search 0)
;; 				(cons :acc-reuse-closed 0) (cons :acc-reuse 0) (cons :acc-current-search 0)))

;; 	       (push (list (cons :problem i) (cons :p 1.0) (cons :r 0.0) (cons :cost (nth 10 ehc-sol)) (cons :time (nth 6 ehc-sol)) (cons :length (nth 7 ehc-sol))
;; 			   (cons :nodes (nth 8 ehc-sol)) (cons :evaluations (nth 9 ehc-sol)))
;; 		     (cdr (assoc :solutions summary-ehc))))
;; 		 (push (list (cons :problem i) (cons :p 1.0) (cons :r 0.0) (cons :cost 0) (cons :time 0) (cons :length 0) (cons :nodes 0) (cons :evaluations 0))
;; 		       (cdr (assoc :solutions summary-ehc)))))
	      ;; 		 (incf (cdr (assoc :number-solved summary-ehc)))
	      ;; 		 (incf (cdr (assoc :acc-cost summary-ehc)) (nth 10 ehc-sol))
	      ;; 		 (incf (cdr (assoc :acc-time summary-ehc)) (nth 6 ehc-sol))
	      ;; 		 (incf (cdr (assoc :acc-nodes summary-ehc)) (nth 8 ehc-sol))
	      ;; 		 (incf (cdr (assoc :acc-evaluations summary-ehc)) (nth 9 ehc-sol)))
;; 		     (push (list (cons :problem i) (cons :p prob-p) (cons :r prob-r)
;; 				 (cons :reuse-closed (/ reuse-closed solved 1.0)) (cons :reuse (/ reuse solved 1.0)) (cons :current-search (/ current-search solved 1.0))
;; 				 (cons :cost (/ cost solved 1.0)) (cons :length (/ length solved 1.0))
;; 				 (cons :time (/ time solved 1.0)) (cons :nodes (/ nodes solved 1.0)) (cons :evaluations (/ evaluations solved 1.0)))
;; 			   (cdr (assoc :solutions summary-errt))))
;; 		       (push (list (cons :problem i) (cons :p prob-p) (cons :r prob-r)
;; 				   (cons :reuse-closed 0) (cons :reuse 0) (cons :current-search 0)
;; 				   (cons :cost 0) (cons :length 0)
;; 				   (cons :time 0) (cons :nodes 0) (cons :evaluations 0))
;; 			     (cdr (assoc :solutions summary-errt))))))))))))

;; (defun summary-results (ehc-solutions errt-solutions sayphi-algorithm algorithm number-repetitions avoided-computations problems-list)
;;   (do* ((summary-ehc (list (cons 'solutions nil) (cons 'number-solved 0) (cons 'acc-cost 0) (cons 'acc-time 0) (cons 'acc-nodes 0) (cons 'acc-evaluations 0)))
;; 	(summary-errt (list (cons 'solutions nil) (cons 'number-solved 0) (cons 'acc-cost 0) (cons 'acc-time 0) (cons 'acc-nodes 0) (cons 'acc-evaluations 0)
;; 			    (cons 'avoided-computations 0)))
;; 	(ehc-sols ehc-solutions (cdr ehc-sols))
;; 	(errt-sols errt-solutions)
;; 	(ehc-sol (car ehc-sols) (car ehc-sols))
;; 	(errt-sol nil)
;; 	(i 1 (1+ i))
;; 	(num-problems (length problems-list))
;; 	(solved 0 0) (nodes 0 0) (time 0 0) (cost 0 0) (evaluations 0))
;;       ((or (null ehc-sols)
;; 	   (null errt-sols))
;;        `((,sayphi-algorithm ,summary-ehc) (,algorithm ,summary-errt)))
;;     (cond ((solution-found ehc-sol)
;; 	   (push (list (cons 'problem (nth (- num-problems i) problems-list)) (cons 'solved t) (cons 'cost (solution-total-cost ehc-sol)) (cons 'time (solution-total-time ehc-sol))
;; 		       (cons 'nodes (solution-num-nodes ehc-sol)) (cons 'evaluations (solution-evaluated-nodes ehc-sol)))
;; 		 (cdr (assoc 'solutions summary-ehc)))
;; 	   (incf (cdr (assoc 'number-solved summary-ehc)))
;; 	   (incf (cdr (assoc 'acc-cost summary-ehc)) (solution-total-cost ehc-sol))
;; 	   (incf (cdr (assoc 'acc-time summary-ehc)) (solution-total-time ehc-sol))
;; 	   (incf (cdr (assoc 'acc-nodes summary-ehc)) (solution-num-nodes ehc-sol))
;; 	   (incf (cdr (assoc 'acc-evaluations summary-ehc)) (solution-evaluated-nodes ehc-sol)))
;; 	  (t (push (list (cons 'problem (nth (- num-problems i) problems-list)) (cons 'solved nil)) (cdr (assoc 'solutions summary-ehc)))))
;;     (dotimes (i number-repetitions)
;;       (setq errt-sol (pop errt-sols))
;;       (cond ((and errt-sol (solution-found errt-sol))
;; 	     (push (list (cons 'problem (nth (- num-problems i) problems-list)) (cons 'solved t) (cons 'cost (solution-total-cost errt-sol)) (cons 'time (solution-total-time errt-sol))
;; 			 (cons 'nodes (solution-num-nodes errt-sol)) (cons 'evaluations (solution-evaluated-nodes errt-sol)))
;; 		   (cdr (assoc 'solutions summary-errt)))
;; 	     (incf solved)
;; 	     (incf cost (solution-total-cost errt-sol))
;; 	     (incf time (solution-total-time errt-sol))
;; 	     (incf nodes (solution-num-nodes errt-sol))
;; 	     (incf evaluations (solution-evaluated-nodes errt-sol)))
;; 	    (t (push (list (cons 'problem (nth (- num-problems i) problems-list)) (cons 'solved nil)) (cdr (assoc 'solutions summary-errt))))))
;;     (incf (cdr (assoc 'number-solved summary-errt)) solved)
;;     (when (> solved 0)
;;       (setf (cdr (assoc 'avoided-computations summary-errt)) (/ avoided-computations solved 1.0))
;;       (incf (cdr (assoc 'acc-cost summary-errt)) (/ cost solved 1.0))
;;       (incf (cdr (assoc 'acc-time summary-errt)) (/ time solved 1.0))
;;       (incf (cdr (assoc 'acc-nodes summary-errt)) (/ nodes solved 1.0))
;;       (incf (cdr (assoc 'acc-evaluations summary-errt)) (/ evaluations solved 1.0)))))

;; (defun summary-results (results-file &key (domain "driverlog-num")  (p (list 0.0 0.3 0.7 1.0)) (r (list 0.0 0.3 0.7 1.0)) (number-repetitions 5) (number-modifications 5)
;; 			(plot-file (concatenate 'string *domains-dir* domain "/result/plot.plt"))
;; 			(summary-solution-format :gnuplot)
;; 			(output-file (concatenate 'string *domains-dir* domain "/result/errt-results."
;; 						  (if (eq summary-solution-format :gnuplot) "dat" (if (eq *say-solution-format* :list) "lisp" "csv"))))
;; 			(planner 'ff)
;; 			(output-configurations 'all) (accumulated-p t) (time-bound most-positive-fixnum) (plot-planner-p t) (dont-plot-zeros-p nil)
;; 			(print-tex-file-p t) (x-labels nil))
;;   (let ((the-results nil)
;; 	(gnuplot-p (or (eq summary-solution-format :gnuplot) (eq *say-solution-format* :list)))
;; 	(i 0)
;; 	(configurations (list (list (cons 1.0 0.0) (cons 'cost 0) (cons 'solved 0) (cons 'nodes 0) (cons 'time 0) (cons 'length 0)))))
;;     (with-open-file (istream results-file :direction :input)
;;       (setq the-results (read istream)))
;;     ;;     (format t "~%Length the results: ~d, Algorithm: ~a" (length the-results) (nth 2 (car the-results)))
;;     (with-open-file (ostream output-file :direction :output :if-exists :supersede :if-does-not-exist :create)
;;       (if gnuplot-p
;; 	  (format ostream
;; 		  "# 0 Prob, 1 Solved, 2 Time, 3 Length, 4 Nodes, 5 Evals, 6 Cost, 7 ReuseClosed, 8 Reuse, 9 CurrentSearch, 10 NumberBetterLength, 11 NumberBetterCost, 12 TotalTimeHeuristic, 13 Unstability (12 AvgTimeHeuristic 13 TotalTimeHeuristic 14 Unstability in PLANNER)")
;; 	  (format ostream
;; 		  ";;  Prob, Solved, Time, Length, Nodes, Evals, Cost, ReuseClosed, Reuse, CurrentSearch, NumberBetterLength, NumberBetterCost, TotalTimeHeuristic"))
;;       (do* ((solved 0) (nodes 0) (time 0) (cost 0) (length 0) (evaluations 0) (reuse-closed 0) (reuse 0) (current-search 0) (number-better-length 0) (number-better-cost 0) (unstability 0)
;; 	    (time-heuristic 0)
;; 	    (results t)
;; 	    ;; 	    (results (cdr the-results) (if (zerop (mod i number-modifications)) (cdr results) results))
;; 	    (aux-results nil)
;; 	    (line "" "")
;; 	    (planner-sol nil) (errt-sol nil)
;; 	    (algorithm nil)
;; 	    (unsolved-by-one nil nil)
;; 	    (first nil)
;; 	    (locally-all-unsolved-p nil)
;; 	    (repetitions 0))
;; 	   ((null results))
;; 	(incf i)
;; 	(if (= 1 i) (setq results the-results))
;; 	;; This is where the solution comes from for each modification and we have to see which is the first solved instance of the problem
;; 	(when (or (and (= number-modifications 1) (= i 1))
;; 		  (= 1 (mod i number-modifications)))
;; 	  (setq results (planner-results planner results))
;; 	  (do ((problem (nth 1 (car results)))
;; 	       (initp t nil)
;; 	       (solvedp (nth 5 (car results)) (nth 5 (car results))))
;; 	      ((or solvedp (null results))
;; 	       (setq results (if results
;; 				 (if initp
;; 				     (planner-results planner (cdr results))
;; 				     (member problem (cdr results) :key #'cadr)))))
;; 	    (setq results (planner-results planner results)))) ;; (cdr results))))
;; 	(setq aux-results results)
;;  	(if *trace-errt-p* (format t "~%Length results: ~d, Algorithm: ~a" (length results) (nth 2 (car results))))
;; 	(when results
;; 	  ;; I see if all configurations solved the problem
;; 	  (when accumulated-p
;; 	    (setq aux-results (planner-results planner aux-results))
;; 	    (setq first (pop aux-results))
;; 	    (setq unsolved-by-one (and plot-planner-p (or (not (nth 5 first)) (> (nth 6 first) time-bound))))
;; 	    ;;  	  (format t "~%Unsolved PLANNER: ~a" unsolved-by-one)
;; 	    (if (not unsolved-by-one)
;; 		(dolist (prob-p (if (listp p) p (list p)))
;; 		  (if (not unsolved-by-one)
;; 		      (dolist (prob-r (if (listp r) r (list r)))
;; 			(when (and (not unsolved-by-one)
;; 				   (<= (+ prob-p prob-r) 1.0)
;; 				   (not (and (= prob-p 1.0) (= prob-r 0.0))))
;; 			  (setq locally-all-unsolved-p t)
;; 			  (dotimes (j (if (and (= prob-p 0.0) (= prob-r 1.0)) 1 number-repetitions))
;; 			    (setq first (pop aux-results))
;; 			    (if (or (eq output-configurations 'all)
;; 				    (member (cons prob-p prob-r) output-configurations :test #'equal))
;; 				(setq locally-all-unsolved-p (and locally-all-unsolved-p (or (not (nth 5 first)) (> (nth 6 first) time-bound))))
;; 				;; 			    (format t "~%Unsolved (~a,~a) repetition ~d: ~a" prob-p prob-r j locally-all-unsolved-p)
;; 				))
;; 			  (if (or (eq output-configurations 'all)
;; 				  (member (cons prob-p prob-r) output-configurations :test #'equal))
;; 			      (setq unsolved-by-one (or unsolved-by-one locally-all-unsolved-p)))))))))
;; 	  (setq results (planner-results planner results))
;; 	  (setq planner-sol (pop results))
;; ;; 	  (setq sayphi-algorithm (or sayphi-algorithm (nth 2 planner-sol)))
;; 	  (if *trace-errt-p*
;; 	      (format t "~%Prob: ~a, Order: ~d, Unsolved: ~a, algorithm: ~a, mod: ~d" (nth 1 planner-sol) i unsolved-by-one (nth 2 planner-sol) (mod i number-modifications)))
;; 	  (if (or (not accumulated-p) (not unsolved-by-one))
;; 	      (cond ((not plot-planner-p) (format ostream "~%~d" i))
;; 		    (accumulated-p
;; 		     (format ostream (if gnuplot-p "~%~d ~d ~4$ ~d ~d ~d ~4$ 0 0 ~d 0 0 ~4$ ~4$ ~d" "~%~d, ~d, ~4$, ~d, ~d, ~d, ~4$, 0, 0, ~d, 0, 0, ~4$, ~4$, ~d") i
;; 			     (if (and (nth 5 planner-sol) (<= (nth 6 planner-sol) time-bound))
;; 				 (incf (cdr (assoc 'solved (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))))
;; 				 (cdr (assoc 'solved (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))))
;; 			     (incf (cdr (assoc 'time (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 6 planner-sol))
;; 			     (incf (cdr (assoc 'length (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 7 planner-sol))
;; 			     (incf (cdr (assoc 'nodes (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 8 planner-sol))
;; 			     (nth 9 planner-sol)
;; 			     (incf (cdr (assoc 'cost (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 10 planner-sol))
;; 			     (nth 7 planner-sol) (nth 17 planner-sol) (nth 18 planner-sol) (nth 20 planner-sol)))
;; 		    ((and (nth 5 planner-sol) (<= (nth 6 planner-sol) time-bound))
;; 		     (format ostream (if gnuplot-p "~%~d 1 ~4$ ~d ~d ~d ~4$ 0 0 ~d 0 0 ~4$ ~4$ ~d" "~%~d, 1, ~4$, ~d, ~d, ~d, ~4$, 0, 0, ~d, 0, 0, ~4$, ~4$, ~d$")
;; 			     i (nth 6 planner-sol) (nth 7 planner-sol) (nth 8 planner-sol) (nth 9 planner-sol) (nth 10 planner-sol) (nth 7 planner-sol)
;; 			     (nth 17 planner-sol) (nth 18 planner-sol) (nth 20 planner-sol)))
;; 		    (t (format ostream (if gnuplot-p "~%~d 0 0.0 0 0 0 0.0 0 0 0 0 0 0.0 ~4$ 0" "~%~d, 0, 0.0, 0, 0, 0, 0.0, 0, 0, 0, 0, 0, 0.0, ~4$, 0") i (nth 18 planner-sol)))))
;; 	  (dolist (prob-p (if (listp p) p (list p)))
;; 	    (dolist (prob-r (if (listp r) r (list r)))
;; 	      (when (and (<= (+ prob-p prob-r) 1.0)
;; 			 (not (and (= prob-p 1.0) (= prob-r 0.0))))
;; 		(setq repetitions (if (and (= prob-p 0.0) (= prob-r 1.0)) 1 number-repetitions))
;; 		(cond ((and (or (not accumulated-p) (not unsolved-by-one))
;; 			    (or (eq output-configurations 'all)
;; 				(member (cons prob-p prob-r) output-configurations :test #'equal)))
;; 		       (setq solved 0 nodes 0 time 0 cost 0 length 0 evaluations 0 reuse-closed 0 reuse 0 current-search 0 number-better-length 0 number-better-cost 0
;; 			     time-heuristic 0 unstability 0)
;; 		       (if (= i 1) ;; so that we know how many ERRT-PLAN configurations we have and which ones and also keep accumulated data
;; 			   (push `((,prob-p . ,prob-r) (cost . ,cost) (solved . ,solved) (nodes . ,nodes) (time . ,time) (length . ,length)) configurations))
;; 		       (dotimes (j repetitions)
;; 			 (setq errt-sol (pop results))
;; 			 (setq algorithm (or algorithm (nth 2 errt-sol)))
;; 			 ;; 			 (format t "~%Algorithm: ~a" (nth 2 errt-sol))
;; 			 (when (and (nth 5 errt-sol) (<= (nth 6 errt-sol) time-bound))
;; 			   (incf solved)
;; 			   (if (< (nth 10 errt-sol) (nth 10 planner-sol)) (incf number-better-cost))
;; 			   (incf cost (nth 10 errt-sol))
;; 			   (if (< (nth 7 errt-sol) (nth 7 planner-sol)) (incf number-better-length))
;; 			   (incf length (nth 7 errt-sol))
;; 			   (incf time (nth 6 errt-sol))
;; 			   (incf nodes (nth 8 errt-sol))
;; 			   (incf evaluations (nth 9 errt-sol))
;; 			   (incf reuse-closed (nth 13 errt-sol))
;; 			   (incf reuse (nth 14 errt-sol))
;; 			   (incf current-search (nth 15 errt-sol))
;; 			   (incf time-heuristic (nth 18 errt-sol))
;; 			   (if (nth 20 errt-sol) ;; for previous executions
;; 			       (incf unstability (nth 20 errt-sol)))))
;; 		       ;;		(incf (cdr (assoc :number-solved summary-errt)) solved)
;; 		       (cond (accumulated-p
;; 			      ;; 			      (format t "~%Before accumulating")
;; 			      ;; 			      (format t "~%Configurations: ~a" configurations)
;; 			      (if gnuplot-p
;; 				  (if (> solved 0)
;; 				      (format ostream " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d"
;; 					      (incf (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ solved repetitions 1.0))
;; 					      (incf (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ time solved))
;; 					      (incf (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ length solved 1.0))
;; 					      (incf (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ nodes solved 1.0))
;; 					      (/ evaluations solved 1.0)
;; 					      (incf (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ cost solved 1.0))
;; 					      (/ reuse-closed solved 1.0) (/ reuse solved 1.0) (/ current-search solved 1.0) number-better-length number-better-cost
;; 					      (/ time-heuristic solved) (/ unstability solved 1.0))
;; 				      (format ostream " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d"
;; 					      (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      0
;; 					      (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      0 0 0 0 0 0 0))
;; 				  (if (> solved 0)
;; 				      (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~2$, ~2$, ~2$, ~2$, ~2$, ~2$, ~d, ~d, ~4$, ~d"
;; 					      i algorithm prob-p prob-r
;; 					      (incf (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ solved repetitions 1.0))
;; 					      (incf (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ cost solved 1.0))
;; 					      (incf (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ time solved))
;; 					      (incf (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ length solved 1.0))
;; 					      (incf (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ nodes solved 1.0))
;; 					      (/ evaluations solved 1.0) (/ reuse-closed solved 1.0) (/ reuse solved 1.0) (/ current-search solved 1.0)
;; 					      number-better-length number-better-cost (/ time-heuristic solved) (/ unstability solved 1.0))
;; 				      (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~2$, ~2$, ~2$, ~2$, ~2$, ~2$, ~d, ~d, ~4$, ~d"
;; 					      i algorithm prob-p prob-r
;; 					      (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      0 0 0 0 0 0 0 0)))
;; 			      ;;  			      (format t "~%After accumulating")
;; 			      ;;  			      (format t "~%Configurations: ~a" configurations)
;; 			      )
;; 			     ((> solved 0)
;; 			      (if gnuplot-p
;; 				  (format ostream " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d"
;; 					  solved (/ time solved) (/ length solved 1.0) (/ nodes solved 1.0) (/ evaluations solved 1.0)  (/ cost solved 1.0)
;; 					  (/ reuse-closed solved 1.0) (/ reuse solved 1.0) (/ current-search solved 1.0) number-better-length number-better-cost (/ time-heuristic solved)
;; 					  (/ unstability solved 1.0))
;; 				  (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~2$, ~2$, ~2$, ~2$, ~2$, ~2$, ~d, ~d, ~4$, ~d"
;; 					  i algorithm prob-p prob-r solved
;; 					  (/ cost solved 1.0) (/ time solved) (/ length solved 1.0) (/ nodes solved 1.0) (/ evaluations solved 1.0)
;; 					  (/ reuse-closed solved 1.0) (/ reuse solved 1.0) (/ current-search solved 1.0) number-better-length number-better-cost (/ time-heuristic solved)
;; 					  (/ unstability solved 1.0))))
;; 			     (t (if gnuplot-p
;; 				    (format ostream  " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d" 0 0.0 0.0 0.0 0.0 0.0 0 0 0 number-better-length number-better-cost 0.0 0)
;; 				    (format ostream "~%~d, ~d, ~a, ~a, 0, 0, 0, 0, 0, 0, 0, 0, 0, ~d, ~d, 0, 0" i algorithm prob-p prob-r number-better-length number-better-cost)))))
;; 		      (t (dotimes (j repetitions)
;; 			   ;; 			   (format t "~%Algorithm: ~a, (~a,~a), (~a,~a)" (nth 2 (car results)) prob-p prob-r (nth 3 (car results)) (nth 4 (car results)))
;; 			   (pop results)))))))
;; 	  (if gnuplot-p
;; 	      (format ostream  " ~a" (if unsolved-by-one 0 1))
;; 	      (format ostream  ", ~a" (if unsolved-by-one 0 1))))))
;;     (if print-tex-file-p (generate-tex-file domain configurations i))
;;     (when gnuplot-p
;;       (generate-plot-file domain (cdr (reverse (mapcar #'car configurations))) output-file plot-file planner plot-planner-p (or accumulated-p dont-plot-zeros-p) x-labels)
;;       (execute-shell-command (format nil "cd; cd ~a~(~a~)/result/; gnuplot plot.plt" *domains-dir* domain)))))

;; (defun summary-results (results-file &key (domain "driverlog")  (p (list 0.0 0.3 0.7 1.0)) (r (list 0.0 0.3 0.7 1.0)) (number-repetitions 5) (number-modifications 5)
;; 			(plot-file (concatenate 'string *domains-dir* domain "/result/plot.plt"))
;; 			(summary-solution-format :gnuplot)
;; 			(output-file (concatenate 'string *domains-dir* domain "/result/errt-results."
;; 						  (if (eq summary-solution-format :gnuplot) "dat" (if (eq *say-solution-format* :list) "lisp" "csv"))))
;; 			(planner 'ff)
;; 			(output-configurations 'all) (accumulated-p t) (time-bound most-positive-fixnum) (plot-planner-p t) (dont-plot-zeros-p nil)
;; 			(print-tex-file-p t) (x-labels nil) (results-fn #'median) (second-results nil))
;;   (let ((the-results nil)
;; 	(gnuplot-p (or (eq summary-solution-format :gnuplot) (eq *say-solution-format* :list)))
;; 	(i 0)
;; 	(configurations (list (list (cons 1.0 0.0) (cons 'cost 0) (cons 'solved 0) (cons 'nodes 0) (cons 'time 0) (cons 'length 0)))))
;;     (with-open-file (istream (concatenate 'string *domains-dir* domain "/result/" results-file) :direction :input)
;;       (setq the-results (read istream)))
;;     ;;     (format t "~%Length the results: ~d, Algorithm: ~a" (length the-results) (nth 2 (car the-results)))
;;     (with-open-file (ostream output-file :direction :output :if-exists :supersede :if-does-not-exist :create)
;;       (if gnuplot-p
;; 	  (format ostream
;; 		  "# 0 Prob, 1 Solved, 2 Time, 3 Length, 4 Nodes, 5 Evals, 6 Cost, 7 ReuseClosed, 8 Reuse, 9 CurrentSearch, 10 NumberBetterLength, 11 NumberBetterCost, 12 TotalTimeHeuristic, 13 Unstability (12 AvgTimeHeuristic 13 TotalTimeHeuristic 14 Unstability in planner) 15 Solved-conf1, 16 Time-conf1, ...")
;; 	  (format ostream
;; 		  ";;  Prob, Solved, Time, Length, Nodes, Evals, Cost, ReuseClosed, Reuse, CurrentSearch, NumberBetterLength, NumberBetterCost, TotalTimeHeuristic"))
;;       (do* ((solved 0) (nodes 0) (time 0) (cost 0) (length 0) (evaluations 0) (reuse-closed 0) (reuse 0) (current-search 0) (number-better-length 0) (number-better-cost 0) (unstability 0)
;; 	    (time-heuristic 0)
;; 	    (results t)
;; 	    ;; 	    (results (cdr the-results) (if (zerop (mod i number-modifications)) (cdr results) results))
;; 	    (aux-results nil)
;; 	    (line "" "")
;; 	    (planner-sol nil) (errt-sol nil)
;; 	    (algorithm nil)
;; 	    (unsolved-by-one nil nil)
;; 	    (first nil)
;; 	    (locally-all-unsolved-p nil)
;; 	    (repetitions 0))
;; 	   ((null results))
;; 	(incf i)
;; 	(if (= 1 i) (setq results the-results))
;; 	;; This is where the solution comes from for each modification and we have to see which is the first solved instance of the problem
;; 	(when (or (and (= number-modifications 1) (= i 1))
;; 		  (= 1 (mod i number-modifications)))
;; 	  (setq results (planner-results planner results))
;; 	  (do ((problem (nth 1 (car results)))
;; 	       (initp t nil)
;; 	       (solvedp (nth 5 (car results)) (nth 5 (car results))))
;; 	      ((or solvedp (null results))
;; 	       (setq results (if results
;; 				 (if initp
;; 				     (planner-results planner (cdr results))
;; 				     (member problem (cdr results) :key #'cadr)))))
;; 	    (setq results (planner-results planner results)))) ;; (cdr results))))
;; 	(setq aux-results results)
;;  	(if *trace-errt-p* (format t "~%Length results: ~d, Algorithm: ~a" (length results) (nth 2 (car results))))
;; 	(when results
;; 	  ;; I see if all configurations solved the problem
;; 	  (when accumulated-p
;; 	    (setq aux-results (planner-results planner aux-results))
;; 	    (setq first (pop aux-results))
;; 	    (setq unsolved-by-one (and plot-planner-p (or (not (nth 5 first)) (> (nth 6 first) time-bound))))
;; 	    ;;  	  (format t "~%Unsolved PLANNER: ~a" unsolved-by-one)
;; 	    (if (not unsolved-by-one)
;; 		(dolist (prob-p (if (listp p) p (list p)))
;; 		  (if (not unsolved-by-one)
;; 		      (dolist (prob-r (if (listp r) r (list r)))
;; 			(when (and (not unsolved-by-one)
;; 				   (<= (+ prob-p prob-r) 1.0)
;; 				   (not (and (= prob-p 1.0) (= prob-r 0.0))))
;; 			  (setq locally-all-unsolved-p t)
;; 			  (dotimes (j (if (and (= prob-p 0.0) (= prob-r 1.0)) 1 number-repetitions))
;; 			    (setq first (pop aux-results))
;; 			    (if (or (eq output-configurations 'all)
;; 				    (member (cons prob-p prob-r) output-configurations :test #'equal))
;; 				(setq locally-all-unsolved-p (and locally-all-unsolved-p (or (not (nth 5 first)) (> (nth 6 first) time-bound))))
;; 				;; 			    (format t "~%Unsolved (~a,~a) repetition ~d: ~a" prob-p prob-r j locally-all-unsolved-p)
;; 				))
;; 			  (if (or (eq output-configurations 'all)
;; 				  (member (cons prob-p prob-r) output-configurations :test #'equal))
;; 			      (setq unsolved-by-one (or unsolved-by-one locally-all-unsolved-p)))))))))
;; 	  (setq results (planner-results planner results))
;; 	  (setq planner-sol (pop results))
;; 	  ;; 	  (setq sayphi-algorithm (or sayphi-algorithm (nth 2 planner-sol)))
;; 	  (if *trace-errt-p*
;; 	      (format t "~%Prob: ~a, Order: ~d, Unsolved: ~a, algorithm: ~a, mod: ~d" (nth 1 planner-sol) i unsolved-by-one (nth 2 planner-sol) (mod i number-modifications)))
;; 	  (if (or (not accumulated-p) (not unsolved-by-one))
;; 	      (cond ((not plot-planner-p) (format ostream "~%~d" i))
;; 		    (accumulated-p
;; 		     (format ostream (if gnuplot-p "~%~d ~d ~4$ ~d ~d ~d ~4$ 0 0 ~d 0 0 ~4$ ~4$ ~d" "~%~d, ~d, ~4$, ~d, ~d, ~d, ~4$, 0, 0, ~d, 0, 0, ~4$, ~4$, ~d")
;; 			     i
;; 			     (if (and (nth 5 planner-sol) (<= (nth 6 planner-sol) time-bound))
;; 				 (incf (cdr (assoc 'solved (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))))
;; 				 (cdr (assoc 'solved (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))))
;; 			     (incf (cdr (assoc 'time (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 6 planner-sol))
;; 			     (incf (cdr (assoc 'length (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 7 planner-sol))
;; 			     (incf (cdr (assoc 'nodes (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 8 planner-sol))
;; 			     (nth 9 planner-sol)
;; 			     (incf (cdr (assoc 'cost (cdr (assoc (cons 1.0 0.0) configurations :test #'equal)))) (nth 10 planner-sol))
;; 			     (nth 7 planner-sol) (nth 17 planner-sol) (nth 18 planner-sol) (nth 20 planner-sol)))
;; 		    ((and (nth 5 planner-sol) (<= (nth 6 planner-sol) time-bound))
;; 		     (format ostream (if gnuplot-p "~%~d 1 ~4$ ~d ~d ~d ~4$ 0 0 ~d 0 0 ~4$ ~4$ ~d" "~%~d, 1, ~4$, ~d, ~d, ~d, ~4$, 0, 0, ~d, 0, 0, ~4$, ~4$, ~d$")
;; 			     i (nth 6 planner-sol) (nth 7 planner-sol) (nth 8 planner-sol) (nth 9 planner-sol) (nth 10 planner-sol) (nth 7 planner-sol)
;; 			     (nth 17 planner-sol) (nth 18 planner-sol) (nth 20 planner-sol)))
;; 		    (t (format ostream (if gnuplot-p "~%~d 0 0.0 0 0 0 0.0 0 0 0 0 0 0.0 ~4$ 0" "~%~d, 0, 0.0, 0, 0, 0, 0.0, 0, 0, 0, 0, 0, 0.0, ~4$, 0") i (nth 18 planner-sol)))))
;; 	  (dolist (prob-p (if (listp p) p (list p)))
;; 	    (dolist (prob-r (if (listp r) r (list r)))
;; 	      (when (and (<= (+ prob-p prob-r) 1.0)
;; 			 (not (and (= prob-p 1.0) (= prob-r 0.0))))
;; 		(setq repetitions (if (and (= prob-p 0.0) (= prob-r 1.0)) 1 number-repetitions))
;; 		(cond ((and (or (not accumulated-p) (not unsolved-by-one))
;; 			    (or (eq output-configurations 'all)
;; 				(member (cons prob-p prob-r) output-configurations :test #'equal)))
;; 		       (setq solved 0 nodes nil time nil cost nil length nil evaluations nil reuse-closed nil reuse nil current-search nil number-better-length 0 number-better-cost 0
;; 			     time-heuristic nil unstability nil)
;; 		       (if (= i 1) ;; so that we know how many ERRT-PLAN configurations we have and which ones and also keep accumulated data
;; 			   (push `((,prob-p . ,prob-r) (cost . 0) (solved . 0) (nodes . 0) (time . 0) (length . 0)) configurations))
;; 		       (dotimes (j repetitions)
;; 			 (setq errt-sol (pop results))
;; 			 (setq algorithm (or algorithm (nth 2 errt-sol)))
;; 			 ;; 			 (format t "~%Algorithm: ~a" (nth 2 errt-sol))
;; 			 (when (and (nth 5 errt-sol) (<= (nth 6 errt-sol) time-bound))
;; 			   (incf solved)
;; 			   (push (nth 6 errt-sol) time)
;; 			   (if (< (nth 7 errt-sol) (nth 7 planner-sol)) (incf number-better-length))
;; 			   (push (nth 7 errt-sol) length)
;; 			   (push (nth 8 errt-sol) nodes)
;; 			   (push (nth 9 errt-sol) evaluations)
;; 			   (if (< (nth 10 errt-sol) (nth 10 planner-sol)) (incf number-better-cost))
;; 			   (push (nth 10 errt-sol) cost)
;; 			   (push (nth 13 errt-sol) reuse-closed)
;; 			   (push (nth 14 errt-sol) reuse)
;; 			   (push (nth 15 errt-sol) current-search)
;; 			   (push (nth 18 errt-sol) time-heuristic)
;; 			   (if (nth 20 errt-sol) ;; for previous executions
;; 			       (push (nth 20 errt-sol) unstability))))
;; 		       ;;		(incf (cdr (assoc :number-solved summary-errt)) solved)
;; 		       (cond (accumulated-p
;; 			      ;; 			      (format t "~%Before accumulating")
;; 			      ;; 			      (format t "~%Configurations: ~a" configurations)
;; 			      (if gnuplot-p
;; 				  (if (> solved 0)
;; 				      (format ostream " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d"
;; 					      (incf (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ solved repetitions 1.0))
;; 					      (incf (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn time solved))
;; 					      (incf (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn length solved))
;; 					      (incf (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn nodes solved))
;; 					      (funcall results-fn evaluations solved)
;; 					      (incf (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn cost solved))
;; 					      (funcall results-fn reuse-closed solved) (funcall results-fn reuse solved) (funcall results-fn current-search solved)
;; 					      number-better-length number-better-cost
;; 					      (funcall results-fn time-heuristic solved) (funcall results-fn unstability solved))
;; 				      (format ostream " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d"
;; 					      (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      0
;; 					      (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      0 0 0 0 0 0 0))
;; 				  (if (> solved 0)
;; 				      (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~2$, ~2$, ~2$, ~2$, ~2$, ~2$, ~d, ~d, ~4$, ~d"
;; 					      i algorithm prob-p prob-r
;; 					      (incf (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (/ solved repetitions 1.0))
;; 					      (incf (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn cost solved))
;; 					      (incf (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn time solved))
;; 					      (incf (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn length solved))
;; 					      (incf (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal)))) (funcall results-fn nodes solved))
;; 					      (funcall results-fn evaluations solved) (funcall results-fn reuse-closed solved)
;; 					      (funcall results-fn reuse solved) (funcall results-fn current-search solved)
;; 					      number-better-length number-better-cost (funcall results-fn time-heuristic solved) (funcall results-fn unstability solved))
;; 				      (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~2$, ~2$, ~2$, ~2$, ~2$, ~2$, ~d, ~d, ~4$, ~d"
;; 					      i algorithm prob-p prob-r
;; 					      (cdr (assoc 'solved (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'cost (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'time (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'length (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      (cdr (assoc 'nodes (cdr (assoc (cons prob-p prob-r) configurations :test #'equal))))
;; 					      0 0 0 0 0 0 0 0)))
;; 			      ;;  			      (format t "~%After accumulating")
;; 			      ;;  			      (format t "~%Configurations: ~a" configurations)
;; 			      )
;; 			     ((> solved 0)
;; 			      (if gnuplot-p
;; 				  (format ostream " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d"
;; 					  solved (funcall results-fn time solved) (funcall results-fn length solved) (funcall results-fn nodes solved)
;; 					  (funcall results-fn evaluations solved)  (funcall results-fn cost solved)
;; 					  (funcall results-fn reuse-closed solved) (funcall results-fn reuse solved) (funcall results-fn current-search solved)
;; 					  number-better-length number-better-cost (funcall results-fn time-heuristic solved)
;; 					  (funcall results-fn unstability solved))
;; 				  (format ostream "~%~d, ~d, ~a, ~a, ~d, ~2$, ~4$, ~2$, ~2$, ~2$, ~2$, ~2$, ~2$, ~d, ~d, ~4$, ~d"
;; 					  i algorithm prob-p prob-r solved
;; 					  (funcall results-fn cost solved) (funcall results-fn time solved) (funcall results-fn length solved)
;; 					  (funcall results-fn nodes solved) (funcall results-fn evaluations solved)
;; 					  (funcall results-fn reuse-closed solved) (funcall results-fn reuse solved) (funcall results-fn current-search solved)
;; 					  number-better-length number-better-cost (funcall results-fn time-heuristic solved)
;; 					  (funcall results-fn unstability solved))))
;; 			     (t (if gnuplot-p
;; 				    (format ostream  " ~d ~4$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~2$ ~d ~d ~4$ ~d" 0 0.0 0.0 0.0 0.0 0.0 0 0 0 number-better-length number-better-cost 0.0 0)
;; 				    (format ostream "~%~d, ~d, ~a, ~a, 0, 0, 0, 0, 0, 0, 0, 0, 0, ~d, ~d, 0, 0" i algorithm prob-p prob-r number-better-length number-better-cost)))))
;; 		      (t (dotimes (j repetitions)
;; 			   ;; 			   (format t "~%Algorithm: ~a, (~a,~a), (~a,~a)" (nth 2 (car results)) prob-p prob-r (nth 3 (car results)) (nth 4 (car results)))
;; 			   (pop results)))))))
;; 	  (if gnuplot-p
;; 	      (format ostream  " ~a" (if unsolved-by-one 0 1))
;; 	      (format ostream  ", ~a" (if unsolved-by-one 0 1))))))
;;     (if print-tex-file-p (generate-tex-file domain configurations i))
;;     (when gnuplot-p
;;       (generate-plot-file domain (cdr (reverse (mapcar #'car configurations))) output-file plot-file planner plot-planner-p (or accumulated-p dont-plot-zeros-p) x-labels second-results)
;;       (execute-shell-command (format nil "cd; cd ~a~(~a~)/result/; gnuplot plot.plt" *domains-dir* domain)))))
