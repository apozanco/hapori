;; Functions to support the execution from a script of ERRT-PLAN

(defvar *trace-errtplan-p* nil)

(defun errtplan-from-exe ()
  ;;  (print (nth 4 *posix-argv*))
  (reload-vars-for-execore)
  (let* ((domain-path (nth 1 *posix-argv*))
;; 	 (domain nil)
;; 	 (domain-file nil)
;; 	 (position (1+ (position #\/ domain-path :from-end t)))
	 (problem (nth 2 *posix-argv*))
	 (plan-file (nth 3 *posix-argv*))
	 (solution nil)
	 (search-options (read-from-string (nth 4 *posix-argv*)))
	 (search-option nil)
	 (expression nil)
	 (default-search-options `((:p 0.7) (:r 0.3))))
    ;; 	 (default-search-options `((:p (list 0.7)) (:r (list 0.3)) (:modify-problem 'from-probset) (:number-repetitions 1) (:say-output-level 1))))
    (if *trace-errtplan-p* (format t "~%Domain: ~s~%Domain-file: ~s~%Problem: ~s~%Search options: ~s" domain-path domain-path problem search-options))
;;     (cond ((find #\/ domain-path)
;; 	   (setq domain-file (subseq domain-path position))
;; 	   (setq domain-path (subseq domain-path 0 (1- position)))
;; 	   (setq domain (if (find #\/ domain-path)
;; 			    (subseq domain-path (1+ (position #\/ domain-path :from-end t)))
;; 			    domain-path)))
;; 	  (t (format t "~%[ERRTPLAN]:Exception >> No domain directory~%")
;; 	     (quit)))
;;     (setq problem (if (find #\/ problem)
;; 		      (subseq problem (1+ (position #\/ problem :from-end t)))
;; 		      problem))
    ;; assumes problem does not have an extension. It works with errt-runset
    ;;     (setq problem (pathname-name (if (find #\/ problem)
    ;; 				     (subseq problem (1+ (position #\/ problem :from-end t)))
    ;; 				     problem)))
    (dolist (option default-search-options)
      (if (not (assoc (car option) search-options))
	  (push option search-options)))
    ;; this is for errt-runset
    ;;     (push `(:initial-solutions (list ,plan-file)) search-options)
    ;;     (push `(:prefix ,problem) search-options)
    ;;     (push (list :modified-probset-prefix problem) search-options)
    (setq search-options (mapcan #'(lambda (option) option) search-options))
    ;;    (format t "~%Domain: ~s~%Domain-file: ~s~%Problem: ~s~%Search options: ~s" domain domain-file problem search-options)
    (setq expression `(errt-planning ,domain-path ,problem ,plan-file ,@search-options :sayphi-paths-p nil))
    ;; this is for errt-runset
    ;;    (setq expression `(errt-runset :domain ,domain :domain-file ,domain-file ,@search-options))
    ;; this is for a sayphi-compatible version
;;     (setq expression `(errt-planning ,domain ,problem ,plan-file :domain-file ,domain-file ,@search-options))
    ;; we do not need to run FF/Sayphi
    (setf *run-plain-sayphi-p* nil)
    (if *trace-errtplan-p* (format t "~2%Evaluating: ~s" expression))
    (setq solution (eval expression))
    (when (solution-p solution)
;;      (format t "~%~%~a~%" solution)
      (write-xml-solutions-for-exe)
      (write-solution-for-exe solution))))
;;       (write-multisolution-for-exe))))

(defmacro errtplan-run (&rest body)
  `(prog1 
    (multiple-value-bind (result condition) (ignore-errors ,@body)
      (if condition
	  (format t "~%[ERRTPLAN]:Exception >> ~a~%" condition)
	  result))
    (quit)
    ))
