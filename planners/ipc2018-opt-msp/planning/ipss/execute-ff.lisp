(in-package "COMMON-LISP-USER")

(defun execute-ff (&key (domain-file "domain.pddl") (problem-file "test.pddl")
			(domain-directory *ff-output-directory*) (output-directory *ff-output-directory*))
  (let ((output-file (concatenate 'string output-directory "ff-output.lisp")))
    (with-open-file (ostream output-file :direction :output :if-exists :supersede :if-does-not-exist :create)
      (format ostream "~%(~a" problem-file))
    (inner-execute-ff domain-directory domain-file problem-file output-directory)
    (with-open-file (ostream output-file :direction :output :if-exists :append :if-does-not-exist :create)
      (format ostream ")"))))
;;  | tail -n 2 -
;;  "t[-_0-9a-zA-Z]*.pddl"

(defun inner-execute-ff (domain-directory domain-file problem-file output-directory)
  (let ((command (concatenate 'string "/Users/dborrajo/planning/Metric-FF/ff -p " 
			      domain-directory " -o " domain-file " -f " problem-file
			      " | grep \"\\([0-9]\\+: \\|total time\\|egmentation\\|FALSE\\|step\\)\""
			      "| sed -e \"s/ff: goal can be simplified to FALSE. No plan will solve it/ nil/\""
			      "| sed -e \"s/step $/ ((*finish*/\""
			      "| sed -e \"s/step[ ][ ]*0:/ ((/\""
			      "| sed -e \"s/[0-9][0-9]*:/)(/\" "
			      "| sed -e \"s/\\([0-9][0-9]*.[0-9][0-9]*\\) seconds total time/)) \\1/\""
			      ">> " output-directory "ff-output.lisp")))
    (execute-shell-command command  "/Users/dborrajo/tmp/run-ff")))
;; 
;;     #-sbcl (run-shell-command command :wait t)
;;     #+sbcl (progn (with-open-file (ostream :direction :output :if-exists :supersede :if-does-not-exist :create)
;; 		    (format ostream "#/bin/bash/~%~a~%" command))
;; 		  (sb-ext:run-program "/bin/bash" (list "/home/dborrajo/tmp/run-ff")))
;;     ))

;; (defun execute-ff (&key (domain-file "domain.pddl") (output-directory *ff-output-directory*)
;; 			(domain-directory *ff-output-directory*) (problem-file "test.pddl"))
;;   (let ((filename nil)
;; 	(output-file (concatenate 'string output-directory "ff-output.lisp")))
;;     (with-open-file (ostream output-file :direction :output :if-exists :supersede
;; 					 :if-does-not-exist :create))
;;     (dolist (file (directory (format nil "~a~a" domain-directory file-prefix)))
;;       (setq filename (concatenate 'string (pathname-name file) ".pddl"))
;;       (with-open-file (ostream output-file
;; 		       :direction :output :if-exists :append
;; 		       :if-does-not-exist :create)
;; 	(format ostream "~%(~a" filename))
;;       (run-shell-command (concatenate 'string "/home/dborrajo/planning/Metric-FF/ff -p " 
;; 				      directory " -o domain.pddl -f " filename
;;  				      " | grep \"\\([0-9]\\+: \\|total time\\|egmentation\\|FALSE\\|step\\)\""
;;  				      "| sed -e \"s/ff: goal can be simplified to FALSE. No plan will solve it/ nil/\""
;;   				      "| sed -e \"s/step $/ ((*finish*/\""
;; 				      "| sed -e \"s/step[ ]\\+0:/ ((/\""
;; 				      "| sed -e \"s/[0-9]\\+:/)(/\" "
;; 				      "| sed -e \"s/\\([0-9]\\+.[0-9]\\+\\) seconds total time/)) \\1/\""
;;  				      ">> " directory "ff-output.lisp"
;; 				      )
;; 			 :wait t)
;;       (with-open-file (ostream output-file
;; 		       :direction :output :if-exists :append
;; 		       :if-does-not-exist :create)
;; 	(format ostream ")")))))

;; It returns the list of number of solved problems by FF under a given time-limit
(defun count-solved-ff-problems (&key (ff-results-file (concatenate 'string *ff-output-directory* "ff-output.lisp"))
				      (time-limit 15))
  (with-open-file (istream ff-results-file :direction :input)
    (do* ((problem (read istream nil 'eof)
		   (read istream nil 'eof))
	  (endp (eq problem 'eof) (eq problem 'eof))
	  (solvedp (and (not endp) (listp (cdr problem)))
		   (and (not endp) (listp (cdr problem))))
	  (time (and solvedp (nth 2 problem))
		(and solvedp (nth 2 problem)))
	  (number-solved (if (and time (<= time time-limit)) 1 0)
			 (if (and time (<= time time-limit))
			     (1+ number-solved)
			   number-solved)))
	(endp number-solved))))

;; It returns the list of solutions generated by FF under a given time-limit
(defun solutions-ff (&key (ff-results-file (concatenate 'string *ff-output-directory* "ff-output.lisp"))
			  (time-limit most-positive-fixnum))
  (with-open-file (istream ff-results-file :direction :input)
    (do* ((problem (read istream nil 'eof)
		   (read istream nil 'eof))
	  (endp (eq problem 'eof) (eq problem 'eof))
	  (solvedp (and (not endp) (listp (cdr problem)))
		   (and (not endp) (listp (cdr problem))))
	  (time (and solvedp (nth 2 problem))
		(and solvedp (nth 2 problem)))
	  (solutions (if (and time (<= time time-limit))
			 (list (nth 1 problem)))
		     (if (and time (<= time time-limit))
			 (cons (nth 1 problem) solutions)
		       solutions)))
	(endp (nreverse solutions)))))
