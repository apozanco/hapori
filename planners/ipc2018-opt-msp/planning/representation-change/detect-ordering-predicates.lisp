(load (concatenate 'string *my-planning-path* "ipss/generic-pddl"))
(defvar *domain-dir* "")
(defvar *domains-dir* (concatenate *my-planning-path* "sayphi/domains/"))
(defvar *predicates-in-action* nil)
(defvar *tracep* nil)

(defun compute-ordering-predicates (domain problem-file
				    &key (domain-file "domain.pddl")
				      (probsets-dir (concatenate 'string *domains-dir* domain "/probsets/")))
  (multiple-value-bind (causal-graph static-predicates)
      (compute-causal-graph domain :domain-file domain-file)
    (let* ((potential-predicates (intersection (get-potential-predicates domain domain-file) static-predicates
					       :test #'(lambda (potential-predicate static-predicate)
							 (eq (car potential-predicate) static-predicate))))
	   ;; 	   (relevant-types (mapcar #'cdr potential-predicates))
	   (problem-def (cdr (read-all-file (concatenate 'string probsets-dir problem-file))))
	   ;;  	   (instances (process-instances (find-argument problem-def :objects)))
	   ;; 	   (relevant-types-instances (remove-if-not #'(lambda (type-instances)
	   ;; 							(member 
 	   (state (find-argument problem-def :init))
	   (ordered-alist (mapcar #'(lambda (predicate-type) (list (car predicate-type)))
				  potential-predicates))
	   (predicate-instances nil)
	   (found nil))
      ;; 	   (goals (give-me-all-goals problem-def))
      ;; 	   (goal-preds (mapcar #'car goals))
      ;; 	   (goal-regression nil)))))
      (dolist (literal state)
	(if (setq predicate-instances (assoc (car literal) ordered-alist))
	    (if (setq found (member (cadr literal) (cdr predicate-instances) :key #'car))
		(if (not (eq (caddr literal) (cdar found)))
		    (setq ordered-alist (remove predicate-instances ordered-alist :test #'equal)))
		(setf (cdr (assoc (car literal) ordered-alist))
		      (insert-in-list (cons (cadr literal) (caddr literal)) (cdr predicate-instances))))))
      ordered-alist)))

(defun insert-in-list (element list)
  (cond ((null list) (list element))
	((eq (car element) (cdar list))
	 (cons (car list)
	       (cons element (cdr list))))
	(t (cons (car list) (insert-in-list element (cdr list))))))

(defun get-potential-predicates (domain domain-file)
  (let* ((domain-def (cdr (read-all-file (concatenate 'string *domains-dir* domain "/" domain-file))))
	 (predicates (find-argument domain-def :predicates))
	 (potential-predicates nil)
	 (params nil))
    (dolist (predicate predicates)
      (setq params (process-instances (cleanup-params (cdr predicate))))
      (if (and (= (length params) 1)
	       (= (length (cdar params)) 2))
	  (push (cons (car predicate) (caar params)) potential-predicates)))
    potential-predicates))

(defun compute-causal-graph (domain &key (domain-file "domain.pddl"))
  (let* ((domain-def (cdr (read-all-file (concatenate 'string *domains-dir* domain "/" domain-file))))
	 (types (process-types (find-argument domain-def :types)))
	 (predicates (find-argument domain-def :predicates))
	 (predicate-names (mapcar #'car predicates))
	 (functions (find-argument domain-def :functions))
	 (constants (cleanup-params (find-argument domain-def :constants)))
	 (actions (give-me-all-actions domain-def))
	 (params nil)
	 (preconds-predicates nil)
	 (causal-graph nil)
	 (static-predicates predicate-names))
    (dolist (action actions)
      (setq params (cleanup-params (nth 3 action)))
      (setq *predicates-in-action* nil)
      (collect-predicates (nth 5 action) #'(lambda (exp) exp))
      (when *tracep*
	(format t "~2%Action: ~a" (nth 1 action))
	(format t "~%Preconds: ~a" *predicates-in-action*))
      (setq preconds-predicates *predicates-in-action*)
      (setq *predicates-in-action* nil)
      (collect-predicates (nth 7 action) #'(lambda (exp) exp))
      (setq static-predicates (set-difference static-predicates (mapcar #'car *predicates-in-action*)))
      (when *tracep*
	(format t "~%Effects: ~a" *predicates-in-action*)
	(format t "~%Static predicates: ~a" static-predicates))
      (dolist (effect-predicate *predicates-in-action*)
	(if (assoc effect-predicate causal-graph :test #'equal)
	    (pushnew (cons (nth 1 action) (cons params preconds-predicates))
		     (cdr (assoc effect-predicate causal-graph :test #'equal))
		     :test #'equal)
	    (push (list effect-predicate (cons (nth 1 action) (cons params preconds-predicates)))
		  causal-graph)))
      (if *tracep* (format t "~%Lifted causal graph: ~a" causal-graph)))
    (values causal-graph static-predicates)))

(defun collect-predicates (exp membership-fn)
  (case (car exp)
    ((and or) (collect-predicates (cdr exp) membership-fn))
    (not (if (and (not (eq (caadr exp) '=))
		  (funcall membership-fn (cadr exp)))
	     (pushnew exp *predicates-in-action* :test #'equal)))
    ((increase decrease assign <= >= + * - / < > when)
     (collect-predicates (cadr exp) membership-fn)
     (if (listp (caddr exp))
	 (collect-predicates (caddr exp) membership-fn)))
    ((forall exists) (collect-predicates (caddr exp) membership-fn))
    (otherwise ;; I hope list of literals or individual literal
     (cond ((listp (car exp))
	    (dolist (literal exp) (collect-predicates literal membership-fn)))
	   ((eq (car exp) '=))
	   ((funcall membership-fn exp)
	    (pushnew exp *predicates-in-action* :test #'equal))
	   (t nil)))))
